<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Histogram & Box plot</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f3f4f6;
      --ink: #1f2328;
      --accent: #3b3f45;
      --accent-2: #8f98a3;
      --card: #ffffff;
      --muted: #6b7280;
      --ring: rgba(31, 35, 40, 0.1);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background:
        radial-gradient(1200px 500px at 10% -10%, rgba(31,35,40,0.08), transparent 60%),
        radial-gradient(900px 400px at 110% 10%, rgba(143,152,163,0.12), transparent 60%),
        var(--bg);
      color: var(--ink);
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      min-height: 100dvh;
    }

    header {
      padding: 36px 22px 12px;
      max-width: 980px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: 0.02em;
      font-size: clamp(28px, 3vw, 40px);
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 12px 22px 60px;
      display: grid;
      gap: 18px;
    }

    .panel {
      background: var(--card);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 18px 50px rgba(31, 28, 23, 0.08);
      border: 1px solid var(--ring);
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="number"], input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 16px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
    }

    textarea {
      width: 100%;
      min-height: 160px;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 14px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      resize: vertical;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button {
      border: none;
      padding: 12px 18px;
      border-radius: 8px;
      font-weight: 600;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      letter-spacing: 0.02em;
      background: linear-gradient(135deg, #3b3f45, #5b616a);
      color: #f6f7f9;
      cursor: pointer;
      box-shadow: 0 10px 26px rgba(31, 35, 40, 0.2);
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button:hover { transform: translateY(-1px); }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .stats-table th,
    .stats-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--ring);
      text-align: left;
    }

    .stats-table th {
      font-weight: 700;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .error {
      color: #b42318;
      font-size: 13px;
      margin-top: 8px;
    }

    .charts {
      display: grid;
      gap: 16px;
      grid-template-columns: 1fr;
      align-items: start;
    }

    .chart-box {
      border: 1px solid var(--ring);
      border-radius: 8px;
      padding: 14px;
      background: #fafafa;
    }

    .chart-title {
      margin: 0 0 8px;
      font-size: 13px;
      font-weight: 700;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .fade-in {
      animation: fadeUp 0.6s ease both;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <header class="fade-in">
    <h1>Histogram & Box plot</h1>
    <div class="subtitle">データコピペで、ヒストグラムと箱ひげ図を描写!</div>
  </header>

  <main>
    <section class="panel fade-in">
      <div class="grid">
        <div>
          <label for="dataInput">データ（カンマ / 改行 / タブ区切り）</label>
          <textarea id="dataInput" placeholder="例: 1, 2, 3\n4\t5\n6"></textarea>
        </div>
        <div>
          <div class="muted" style="margin-bottom: 8px;">基本統計量（生データ）</div>
          <table class="stats-table">
            <thead>
              <tr>
                <th>指標</th>
                <th>値</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>COUNT</td><td id="count">-</td></tr>
              <tr><td>平均値</td><td id="mean">-</td></tr>
              <tr><td>最小値</td><td id="min">-</td></tr>
              <tr><td>25% percentile</td><td id="p25">-</td></tr>
              <tr><td>中央値</td><td id="median">-</td></tr>
              <tr><td>75% percentile</td><td id="p75">-</td></tr>
              <tr><td>90% percentile</td><td id="p90">-</td></tr>
              <tr><td>95% percentile</td><td id="p95">-</td></tr>
              <tr><td>最大値</td><td id="max">-</td></tr>
              <tr><td>標準偏差</td><td id="stddev">-</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="panel fade-in">
      <div class="grid">
        <div>
          <div style="margin-bottom: 12px;">
            <label for="binWidth">bin の幅</label>
            <input type="number" id="binWidth" min="0" step="0.01" value="1" />
          </div>
          <div style="margin-bottom: 12px;">
            <label for="filterMin">データフィルタ（これ以上を除外）</label>
            <input type="number" id="filterMin" step="0.01" placeholder="未入力で無効" />
          </div>
          <div style="margin-bottom: 12px;">
            <label for="filterMax">データフィルタ（これ以下を除外）</label>
            <input type="number" id="filterMax" step="0.01" placeholder="未入力で無効" />
          </div>
          <label class="toggle">
            <input type="checkbox" id="splitZero" />
            0 を切り出す
          </label>
        </div>
        <div>
          <div class="actions" style="margin-top: 6px;">
            <button id="calcBtn">作成する</button>
            <div id="error" class="error"></div>
          </div>
          <div class="muted" style="margin-top: 10px;" id="excludedCount">除外数: -</div>
        </div>
      </div>
    </section>

    <section class="panel fade-in">
      <div class="charts">
        <div class="chart-box">
          <div class="chart-title">Histogram</div>
          <div id="histChart"></div>
        </div>
        <div class="chart-box">
          <div class="chart-title">Box Plot</div>
          <div id="boxPlot"></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const parseData = (raw) => {
      return raw
        .split(/[\n\t,]+/)
        .map((v) => v.trim())
        .filter((v) => v.length > 0)
        .map((v) => Number(v))
        .filter((v) => Number.isFinite(v));
    };

    const applyFilter = (values, min, max) => {
      let excluded = 0;
      const filtered = values.filter((v) => {
        if (Number.isFinite(min) && v >= min) {
          excluded += 1;
          return false;
        }
        if (Number.isFinite(max) && v <= max) {
          excluded += 1;
          return false;
        }
        return true;
      });
      return { filtered, excluded };
    };

    const buildBins = (values, width, splitZero, allInt) => {
      if (values.length === 0) return { bins: [], zeroCount: 0 };

      let zeroCount = 0;
      const nonZero = splitZero
        ? values.filter((v) => {
            if (v === 0) zeroCount += 1;
            return v !== 0;
          })
        : values;

      if (nonZero.length === 0) return { bins: [], zeroCount };

      const min = Math.min(...nonZero);
      const max = Math.max(...nonZero);
      const bins = [];

      if (splitZero) {
        const minIdx = min < 0 ? Math.floor(min / width) : (allInt && width === 1 ? 1 : 0);
        const maxIdx = max > 0 ? Math.floor(max / width) : -1;

        for (let i = minIdx; i <= maxIdx; i += 1) {
          if (allInt && width === 1 && i === 0) continue;
          const start = i * width;
          const end = (i + 1) * width;
          if (end === 0) {
            bins.push({ start, end, count: 0, endIsZeroBoundary: true });
          } else {
            bins.push({ start, end, count: 0, endIsZeroBoundary: false });
          }
        }

        nonZero.forEach((v) => {
          const idx = Math.floor(v / width);
          const target = bins.findIndex((b) => b.start <= v && v < b.end);
          if (target >= 0) bins[target].count += 1;
        });
      } else {
        const minIdx = Math.floor(min / width);
        const maxIdx = Math.floor(max / width);
        for (let i = minIdx; i <= maxIdx; i += 1) {
          bins.push({
            start: i * width,
            end: (i + 1) * width,
            count: 0,
            endIsZeroBoundary: false,
          });
        }
        nonZero.forEach((v) => {
          const idx = Math.floor(v / width) - minIdx;
          if (bins[idx]) bins[idx].count += 1;
        });
      }

      return { bins, zeroCount };
    };

    const renderHistogram = (bins, zeroCount, width, splitZero, allInt) => {
      const container = document.getElementById("histChart");
      if (bins.length === 0 && zeroCount === 0) {
        container.innerHTML = "";
        return;
      }

      const chartWidth = 720;
      const chartHeight = 320;
      const pad = { top: 20, right: 20, bottom: 44, left: 48 };
      const innerW = chartWidth - pad.left - pad.right;
      const innerH = chartHeight - pad.top - pad.bottom;

      const dataBins = [...bins];
      if (zeroCount > 0) {
        const zeroBin = { start: 0, end: 0, count: zeroCount, isZero: true };
        const insertAt = dataBins.findIndex((b) => b.start >= 0);
        if (insertAt === -1) {
          dataBins.push(zeroBin);
        } else {
          dataBins.splice(insertAt, 0, zeroBin);
        }
      }

      const maxCount = Math.max(...dataBins.map((b) => b.count), 1);
      const barGap = 6;
      const barW = (innerW - barGap * (dataBins.length - 1)) / dataBins.length;

      const xFor = (i) => pad.left + i * (barW + barGap);
      const yFor = (v) => pad.top + innerH - (v / maxCount) * innerH;

      const svg = [
        `<svg viewBox="0 0 ${chartWidth} ${chartHeight}" role="img" aria-label="Histogram">`,
        `<rect x="0" y="0" width="${chartWidth}" height="${chartHeight}" fill="transparent" />`,
        `<line x1="${pad.left}" y1="${pad.top + innerH}" x2="${pad.left + innerW}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.2)" />`,
        `<line x1="${pad.left}" y1="${pad.top}" x2="${pad.left}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.2)" />`,
      ];

      dataBins.forEach((b, i) => {
        const x = xFor(i);
        const y = yFor(b.count);
        const h = pad.top + innerH - y;
        const color = "#999999";
        const radius = 3;

        const path = [
          `M ${x} ${y + radius}`,
          `Q ${x} ${y} ${x + radius} ${y}`,
          `L ${x + barW - radius} ${y}`,
          `Q ${x + barW} ${y} ${x + barW} ${y + radius}`,
          `L ${x + barW} ${y + h}`,
          `L ${x} ${y + h}`,
          `Z`,
        ].join(" ");

        svg.push(`<path d="${path}" fill="${color}" opacity="0.9" />`);

        const isIntWidth = Number.isInteger(width);
        const fmt = (v) => (isIntWidth ? v.toFixed(0) : v.toFixed(2));
        let label = "";
        if (b.isZero) {
          label = "0";
        } else if (allInt && width === 1) {
          label = fmt(b.start);
        } else if (splitZero && b.start === 0) {
          label = `(0, ${fmt(b.end)})`;
        } else {
          label = `[${fmt(b.start)}, ${fmt(b.end)})`;
        }
        const labelX = x + barW / 2;
        svg.push(
          `<text x="${labelX}" y="${pad.top + innerH + 18}" text-anchor="middle" font-size="10" fill="#6b7280">${label}</text>`
        );
      });

      svg.push(
        `<text x="${pad.left - 10}" y="${pad.top + 4}" text-anchor="end" font-size="11" fill="#6b7280">${maxCount}</text>`,
        `<text x="${pad.left - 10}" y="${pad.top + innerH}" text-anchor="end" font-size="11" fill="#6b7280">0</text>`
      );

      svg.push(`</svg>`);
      container.innerHTML = svg.join("");
    };

    const quantile = (sorted, q) => {
      if (sorted.length === 0) return NaN;
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      }
      return sorted[base];
    };

    const formatStat = (v) => {
      if (!Number.isFinite(v)) return "-";
      return Number.isInteger(v) ? v.toFixed(0) : v.toFixed(2);
    };

    const renderBoxPlot = (values) => {
      const container = document.getElementById("boxPlot");
      if (values.length === 0) {
        container.innerHTML = "";
        return;
      }

      const sorted = [...values].sort((a, b) => a - b);
      const q1 = quantile(sorted, 0.25);
      const median = quantile(sorted, 0.5);
      const q3 = quantile(sorted, 0.75);
      const iqr = q3 - q1;
      const lowerFence = q1 - 1.5 * iqr;
      const upperFence = q3 + 1.5 * iqr;
      const inliers = sorted.filter((v) => v >= lowerFence && v <= upperFence);
      const outliers = sorted.filter((v) => v < lowerFence || v > upperFence);
      const whiskerMin = inliers[0] ?? sorted[0];
      const whiskerMax = inliers[inliers.length - 1] ?? sorted[sorted.length - 1];
      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;

      const width = 720;
      const height = 140;
      const pad = { top: 20, right: 28, bottom: 24, left: 28 };
      const innerW = width - pad.left - pad.right;
      const midY = pad.top + (height - pad.top - pad.bottom) / 2;
      const span = (sorted[sorted.length - 1] - sorted[0]) || 1;
      const xFor = (v) => pad.left + ((v - sorted[0]) / span) * innerW;

      const minX = xFor(whiskerMin);
      const maxX = xFor(whiskerMax);
      const q1X = xFor(q1);
      const q3X = xFor(q3);
      const medX = xFor(median);
      const meanX = xFor(mean);

      const boxH = 36;
      const whiskerH = 22;
      const outlierY = midY;

      const svg = [
        `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Box plot">`,
        `<rect x="0" y="0" width="${width}" height="${height}" fill="transparent" />`,
        `<line x1="${minX}" y1="${midY}" x2="${maxX}" y2="${midY}" stroke="#6b6b6b" stroke-width="2" />`,
        `<line x1="${minX}" y1="${midY - whiskerH / 2}" x2="${minX}" y2="${midY + whiskerH / 2}" stroke="#6b6b6b" stroke-width="2" />`,
        `<line x1="${maxX}" y1="${midY - whiskerH / 2}" x2="${maxX}" y2="${midY + whiskerH / 2}" stroke="#6b6b6b" stroke-width="2" />`,
        `<rect x="${q1X}" y="${midY - boxH / 2}" width="${Math.max(q3X - q1X, 1)}" height="${boxH}" fill="#e0e0e0" stroke="#6b6b6b" stroke-width="2" />`,
        `<line x1="${medX}" y1="${midY - boxH / 2}" x2="${medX}" y2="${midY + boxH / 2}" stroke="#3b3f45" stroke-width="3" />`,
        `<polygon points="${meanX - 4},${midY + 4} ${meanX + 4},${midY + 4} ${meanX},${midY - 4}" fill="#2f8f4e" />`,
        `<text x="${minX}" y="${midY + boxH / 2 + 18}" text-anchor="start" font-size="11" fill="#6b7280">${formatStat(whiskerMin)}</text>`,
        `<text x="${maxX}" y="${midY + boxH / 2 + 18}" text-anchor="end" font-size="11" fill="#6b7280">${formatStat(whiskerMax)}</text>`,
        `</svg>`,
      ];

      if (outliers.length > 0) {
        const points = outliers
          .map((v) => {
            const x = xFor(v);
            return `<circle cx="${x}" cy="${outlierY}" r="3" fill="#6b6b6b" />`;
          })
          .join("");
        svg.splice(2, 0, points);
      }

      container.innerHTML = svg.join("");
    };

    const updateStats = (values) => {
      if (values.length === 0) {
        document.getElementById("count").textContent = "-";
        document.getElementById("mean").textContent = "-";
        document.getElementById("min").textContent = "-";
        document.getElementById("p25").textContent = "-";
        document.getElementById("median").textContent = "-";
        document.getElementById("p75").textContent = "-";
        document.getElementById("p90").textContent = "-";
        document.getElementById("p95").textContent = "-";
        document.getElementById("max").textContent = "-";
        document.getElementById("stddev").textContent = "-";
        return;
      }
      const min = Math.min(...values);
      const max = Math.max(...values);
      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
      const variance =
        values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
      const stddev = Math.sqrt(variance);
      const sorted = [...values].sort((a, b) => a - b);
      const p25 = quantile(sorted, 0.25);
      const median = quantile(sorted, 0.5);
      const p75 = quantile(sorted, 0.75);
      const p90 = quantile(sorted, 0.9);
      const p95 = quantile(sorted, 0.95);

      document.getElementById("count").textContent = values.length;
      document.getElementById("mean").textContent = formatStat(mean);
      document.getElementById("min").textContent = formatStat(min);
      document.getElementById("p25").textContent = formatStat(p25);
      document.getElementById("median").textContent = formatStat(median);
      document.getElementById("p75").textContent = formatStat(p75);
      document.getElementById("p90").textContent = formatStat(p90);
      document.getElementById("p95").textContent = formatStat(p95);
      document.getElementById("max").textContent = formatStat(max);
      document.getElementById("stddev").textContent = formatStat(stddev);
    };

    const setExcludedCount = (excluded) => {
      const el = document.getElementById("excludedCount");
      if (el) el.textContent = `除外数: ${excluded}`;
    };

    const updateRawStats = () => {
      const raw = document.getElementById("dataInput").value;
      const values = parseData(raw);
      updateStats(values);
      setExcludedCount("-");
    };

    const buildHistogram = () => {
      const raw = document.getElementById("dataInput").value;
      const binWidth = Number(document.getElementById("binWidth").value);
      const filterMin = document.getElementById("filterMin").value;
      const filterMax = document.getElementById("filterMax").value;
      const splitZero = document.getElementById("splitZero").checked;

      const errorEl = document.getElementById("error");
      errorEl.textContent = "";

      if (!Number.isFinite(binWidth) || binWidth <= 0) {
        errorEl.textContent = "bin の幅は 0 より大きい数値を入力してください。";
        return;
      }

      const values = parseData(raw);
      const minVal = filterMin === "" ? NaN : Number(filterMin);
      const maxVal = filterMax === "" ? NaN : Number(filterMax);

      const { filtered, excluded } = applyFilter(values, minVal, maxVal);
      const allInt = filtered.length > 0 && filtered.every((v) => Number.isInteger(v));
      const { bins, zeroCount } = buildBins(filtered, binWidth, splitZero, allInt);
      renderHistogram(bins, zeroCount, binWidth, splitZero, allInt);
      renderBoxPlot(filtered);
      setExcludedCount(excluded);
    };

    document.getElementById("calcBtn").addEventListener("click", buildHistogram);
    document.getElementById("dataInput").addEventListener("input", updateRawStats);
    updateRawStats();
  </script>
</body>
</html>
