<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Histogram & Box plot</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f3f4f6;
      --ink: #1f2328;
      --accent: #3b3f45;
      --accent-2: #8f98a3;
      --card: #ffffff;
      --muted: #6b7280;
      --ring: rgba(31, 35, 40, 0.1);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background:
        radial-gradient(1200px 500px at 10% -10%, rgba(31,35,40,0.08), transparent 60%),
        radial-gradient(900px 400px at 110% 10%, rgba(143,152,163,0.12), transparent 60%),
        var(--bg);
      color: var(--ink);
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      min-height: 100dvh;
    }

    header {
      padding: 36px 22px 12px;
      max-width: 980px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: 0.02em;
      font-size: clamp(28px, 3vw, 40px);
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 12px 22px 60px;
      display: grid;
      gap: 18px;
    }

    .panel {
      background: var(--card);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 18px 50px rgba(31, 28, 23, 0.08);
      border: 1px solid var(--ring);
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="number"], input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 16px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
    }

    textarea {
      width: 100%;
      min-height: 160px;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 14px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      resize: vertical;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button {
      border: none;
      padding: 12px 18px;
      border-radius: 8px;
      font-weight: 600;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      letter-spacing: 0.02em;
      background: linear-gradient(135deg, #3b3f45, #5b616a);
      color: #f6f7f9;
      cursor: pointer;
      box-shadow: 0 10px 26px rgba(31, 35, 40, 0.2);
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button:hover { transform: translateY(-1px); }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .stats-table th,
    .stats-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--ring);
      text-align: left;
    }

    .stats-table th {
      font-weight: 700;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .error {
      color: #b42318;
      font-size: 13px;
      margin-top: 8px;
    }

    .charts {
      display: grid;
      gap: 16px;
      grid-template-columns: 1fr;
      align-items: start;
    }

    .chart-box {
      border: 1px solid var(--ring);
      border-radius: 8px;
      padding: 14px;
      background: #fafafa;
    }

    .chart-title {
      margin: 0 0 8px;
      font-size: 13px;
      font-weight: 700;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .fade-in {
      animation: fadeUp 0.6s ease both;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <header class="fade-in">
    <h1>Histogram & Box plot</h1>
    <div class="subtitle">データコピペで、ヒストグラムと箱ひげ図を描写!</div>
  </header>

  <main>
    <section class="panel fade-in">
      <div class="grid">
        <div>
          <label for="dataInput">データ（カンマ or 改行 or タブ区切り）</label>
          <textarea id="dataInput" placeholder="例: 1,2,3"></textarea>
          <div class="muted" style="margin-top: 6px;" id="delimiterNote"></div>
        </div>
        <div>
          <div class="muted" style="margin-bottom: 8px;">基本統計量</div>
          <table class="stats-table">
            <thead>
              <tr>
                <th>指標</th>
                <th>値</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>count</td><td id="count">-</td></tr>
              <tr><td>mean</td><td id="mean">-</td></tr>
              <tr><td>std</td><td id="stddev">-</td></tr>
              <tr><td>min</td><td id="min">-</td></tr>
              <tr><td>25%</td><td id="p25">-</td></tr>
              <tr><td>50%</td><td id="median">-</td></tr>
              <tr><td>75%</td><td id="p75">-</td></tr>
              <tr><td>90%</td><td id="p90">-</td></tr>
              <tr><td>95%</td><td id="p95">-</td></tr>
              <tr><td>max</td><td id="max">-</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="panel fade-in">
      <div class="grid">
        <div>
          <div style="margin-bottom: 12px;">
            <label for="binWidth">bin の幅</label>
            <input type="number" id="binWidth" min="0" step="0.01" value="1" />
          </div>
          <div style="margin-bottom: 12px;">
            <label for="filterMax">フィルタlower</label>
            <input type="number" id="filterMax" step="0.01" placeholder="これ以下を可視化から除外" />
          </div>
          <div style="margin-bottom: 12px;">
            <label for="filterMin">フィルタupper</label>
            <input type="number" id="filterMin" step="0.01" placeholder="これ以上を可視化から除外" />
          </div>
          <label class="toggle">
            <input type="checkbox" id="splitZero" />
            0 を切り出す
          </label>
        </div>
        <div>
          <div class="error" id="error"></div>
          <div class="muted" style="margin-top: 10px;" id="excludedCount">除外数: -</div>
        </div>
      </div>
    </section>

    <section class="panel fade-in">
      <div class="charts">
        <div class="chart-box">
          <div class="chart-title">Histogram</div>
          <div id="histChart"></div>
        </div>
        <div class="chart-box">
          <div class="chart-title">Box Plot</div>
          <div id="boxPlot"></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const parseData = (raw) => {
      const noteEl = document.getElementById("delimiterNote");
      if (noteEl) noteEl.textContent = "";
      const hasTab = raw.includes("\t");
      const hasNewline = raw.includes("\n");
      const hasComma = raw.includes(",");
      const hasPercent = raw.includes("%");

      let parts = [];
      if (hasTab) {
        parts = raw.split(/\t+/);
      } else if (hasNewline) {
        parts = raw.split(/\n+/);
      } else {
        parts = raw.split(/,+/);
      }

      const notes = [];
      if (noteEl && hasComma && (hasTab || hasNewline)) {
        notes.push(
          hasTab
            ? "タブ区切りとして検出しています。カンマは除去して扱います。"
            : "改行区切りとして検出しています。カンマは除去して扱います。"
        );
      }
      if (noteEl && hasPercent) {
        notes.push("百分率に直して扱います。");
      }
      if (noteEl && notes.length > 0) {
        noteEl.textContent = notes.join(" ");
      }

      return parts
        .map((v) => v.trim())
        .filter((v) => v.length > 0)
        .map((v) => {
          let cleaned = v;
          if (hasTab || hasNewline) cleaned = cleaned.replace(/,/g, "");
          if (hasPercent) cleaned = cleaned.replace(/%/g, "");
          const num = Number(cleaned);
          if (!Number.isFinite(num)) return NaN;
          return hasPercent ? num / 100 : num;
        })
        .filter((v) => Number.isFinite(v));
    };

    const applyFilter = (values, min, max) => {
      let excluded = 0;
      const filtered = values.filter((v) => {
        if (Number.isFinite(min) && v >= min) {
          excluded += 1;
          return false;
        }
        if (Number.isFinite(max) && v <= max) {
          excluded += 1;
          return false;
        }
        return true;
      });
      return { filtered, excluded };
    };

    const buildBins = (values, width, splitZero, allInt) => {
      if (values.length === 0) return { bins: [], zeroCount: 0 };

      let zeroCount = 0;
      const nonZero = splitZero
        ? values.filter((v) => {
            if (v === 0) zeroCount += 1;
            return v !== 0;
          })
        : values;

      if (nonZero.length === 0) return { bins: [], zeroCount };

      const min = Math.min(...nonZero);
      const max = Math.max(...nonZero);
      const bins = [];

      if (splitZero) {
        const minIdx = min < 0 ? Math.floor(min / width) : (allInt && width === 1 ? 1 : 0);
        const maxIdx = max > 0 ? Math.floor(max / width) : -1;

        for (let i = minIdx; i <= maxIdx; i += 1) {
          if (allInt && width === 1 && i === 0) continue;
          const start = i * width;
          const end = (i + 1) * width;
          if (end === 0) {
            bins.push({ start, end, count: 0, endIsZeroBoundary: true });
          } else {
            bins.push({ start, end, count: 0, endIsZeroBoundary: false });
          }
        }

        nonZero.forEach((v) => {
          const idx = Math.floor(v / width);
          const target = bins.findIndex((b) => b.start <= v && v < b.end);
          if (target >= 0) bins[target].count += 1;
        });
      } else {
        const minIdx = Math.floor(min / width);
        const maxIdx = Math.floor(max / width);
        for (let i = minIdx; i <= maxIdx; i += 1) {
          bins.push({
            start: i * width,
            end: (i + 1) * width,
            count: 0,
            endIsZeroBoundary: false,
          });
        }
        nonZero.forEach((v) => {
          const idx = Math.floor(v / width) - minIdx;
          if (bins[idx]) bins[idx].count += 1;
        });
      }

      return { bins, zeroCount };
    };

    const renderHistogram = (bins, zeroCount, width, splitZero, allInt) => {
      const container = document.getElementById("histChart");
      if (bins.length === 0 && zeroCount === 0) {
        container.innerHTML = "";
        return;
      }

      const chartWidth = 720;
      const chartHeight = 320;
      const padBottom = (bins.length + (zeroCount > 0 ? 1 : 0)) >= 11 ? 72 : 44;
      const pad = { top: 20, right: 20, bottom: padBottom, left: 48 };
      const innerW = chartWidth - pad.left - pad.right;
      const innerH = chartHeight - pad.top - pad.bottom;

      const dataBins = [...bins];
      if (zeroCount > 0) {
        const zeroBin = { start: 0, end: 0, count: zeroCount, isZero: true };
        const insertAt = dataBins.findIndex((b) => b.start >= 0);
        if (insertAt === -1) {
          dataBins.push(zeroBin);
        } else {
          dataBins.splice(insertAt, 0, zeroBin);
        }
      }

      const maxCount = Math.max(...dataBins.map((b) => b.count), 1);
      const barGap = 6;
      const barW = (innerW - barGap * (dataBins.length - 1)) / dataBins.length;

      const xFor = (i) => pad.left + i * (barW + barGap);
      const yFor = (v) => pad.top + innerH - (v / maxCount) * innerH;

      const svg = [
        `<svg viewBox="0 0 ${chartWidth} ${chartHeight}" role="img" aria-label="Histogram">`,
        `<rect x="0" y="0" width="${chartWidth}" height="${chartHeight}" fill="transparent" />`,
        `<line x1="${pad.left}" y1="${pad.top + innerH}" x2="${pad.left + innerW}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.2)" />`,
        `<line x1="${pad.left}" y1="${pad.top}" x2="${pad.left}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.2)" />`,
      ];

      const rotateLabels = dataBins.length >= 11;
      dataBins.forEach((b, i) => {
        const x = xFor(i);
        const y = yFor(b.count);
        const h = pad.top + innerH - y;
        const color = "#999999";
        const radius = 3;

        const path = [
          `M ${x} ${y + radius}`,
          `Q ${x} ${y} ${x + radius} ${y}`,
          `L ${x + barW - radius} ${y}`,
          `Q ${x + barW} ${y} ${x + barW} ${y + radius}`,
          `L ${x + barW} ${y + h}`,
          `L ${x} ${y + h}`,
          `Z`,
        ].join(" ");

        svg.push(`<path d="${path}" fill="${color}" opacity="0.9" />`);

        const isIntWidth = Number.isInteger(width);
        const fmt = (v) => (isIntWidth ? v.toFixed(0) : v.toFixed(2));
        let label = "";
        if (b.isZero) {
          label = "0";
        } else if (allInt && width === 1) {
          label = fmt(b.start);
        } else if (splitZero && b.start === 0) {
          label = `(0, ${fmt(b.end)})`;
        } else {
          label = `[${fmt(b.start)}, ${fmt(b.end)})`;
        }
        const labelX = x + barW / 2;
        if (rotateLabels) {
          svg.push(
            `<text x="${labelX}" y="${pad.top + innerH + 18}" text-anchor="end" font-size="10" fill="#6b7280" transform="rotate(-45 ${labelX} ${pad.top + innerH + 18})">${label}</text>`
          );
        } else {
          svg.push(
            `<text x="${labelX}" y="${pad.top + innerH + 18}" text-anchor="middle" font-size="10" fill="#6b7280">${label}</text>`
          );
        }
      });

      svg.push(
        `<text x="${pad.left - 10}" y="${pad.top + 4}" text-anchor="end" font-size="11" fill="#6b7280">${maxCount}</text>`,
        `<text x="${pad.left - 10}" y="${pad.top + innerH}" text-anchor="end" font-size="11" fill="#6b7280">0</text>`
      );

      svg.push(`</svg>`);
      container.innerHTML = svg.join("");
    };

    const quantile = (sorted, q) => {
      if (sorted.length === 0) return NaN;
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      }
      return sorted[base];
    };

    const formatStat = (v) => {
      if (!Number.isFinite(v)) return "-";
      return Number.isInteger(v) ? v.toFixed(0) : v.toFixed(2);
    };

    const renderBoxPlot = (values) => {
      const container = document.getElementById("boxPlot");
      if (values.length === 0) {
        container.innerHTML = "";
        return;
      }

      const sorted = [...values].sort((a, b) => a - b);
      const q1 = quantile(sorted, 0.25);
      const median = quantile(sorted, 0.5);
      const q3 = quantile(sorted, 0.75);
      const iqr = q3 - q1;
      const lowerFence = q1 - 1.5 * iqr;
      const upperFence = q3 + 1.5 * iqr;
      const inliers = sorted.filter((v) => v >= lowerFence && v <= upperFence);
      const outliers = sorted.filter((v) => v < lowerFence || v > upperFence);
      const whiskerMin = inliers[0] ?? sorted[0];
      const whiskerMax = inliers[inliers.length - 1] ?? sorted[sorted.length - 1];
      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;

      const width = 720;
      const height = 140;
      const pad = { top: 20, right: 28, bottom: 24, left: 28 };
      const innerW = width - pad.left - pad.right;
      const midY = pad.top + (height - pad.top - pad.bottom) / 2;
      const span = (sorted[sorted.length - 1] - sorted[0]) || 1;
      const xFor = (v) => pad.left + ((v - sorted[0]) / span) * innerW;

      const minX = xFor(whiskerMin);
      const maxX = xFor(whiskerMax);
      const q1X = xFor(q1);
      const q3X = xFor(q3);
      const medX = xFor(median);
      const meanX = xFor(mean);

      const boxH = 36;
      const whiskerH = 22;
      const outlierY = midY;

      const svg = [
        `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Box plot">`,
        `<rect x="0" y="0" width="${width}" height="${height}" fill="transparent" />`,
        `<line x1="${minX}" y1="${midY}" x2="${maxX}" y2="${midY}" stroke="#6b6b6b" stroke-width="2" />`,
        `<line x1="${minX}" y1="${midY - whiskerH / 2}" x2="${minX}" y2="${midY + whiskerH / 2}" stroke="#6b6b6b" stroke-width="2" />`,
        `<line x1="${maxX}" y1="${midY - whiskerH / 2}" x2="${maxX}" y2="${midY + whiskerH / 2}" stroke="#6b6b6b" stroke-width="2" />`,
        `<rect x="${q1X}" y="${midY - boxH / 2}" width="${Math.max(q3X - q1X, 1)}" height="${boxH}" fill="#e0e0e0" stroke="#6b6b6b" stroke-width="2" />`,
        `<line x1="${medX}" y1="${midY - boxH / 2}" x2="${medX}" y2="${midY + boxH / 2}" stroke="#3b3f45" stroke-width="3" />`,
        `<polygon points="${meanX - 4},${midY + 4} ${meanX + 4},${midY + 4} ${meanX},${midY - 4}" fill="#2f8f4e" />`,
        `<text x="${q1X}" y="${midY + boxH / 2 + 18}" text-anchor="middle" font-size="11" fill="#6b7280">${formatStat(q1)}</text>`,
        `<text x="${medX}" y="${midY + boxH / 2 + 18}" text-anchor="middle" font-size="11" fill="#6b7280">${formatStat(median)}</text>`,
        `<text x="${q3X}" y="${midY + boxH / 2 + 18}" text-anchor="middle" font-size="11" fill="#6b7280">${formatStat(q3)}</text>`,
        `</svg>`,
      ];

      if (outliers.length > 0) {
        const points = outliers
          .map((v) => {
            const x = xFor(v);
            return `<circle cx="${x}" cy="${outlierY}" r="3" fill="#6b6b6b" />`;
          })
          .join("");
        svg.splice(2, 0, points);
      }

      container.innerHTML = svg.join("");
    };

    const updateStats = (values) => {
      if (values.length === 0) {
        document.getElementById("count").textContent = "-";
        document.getElementById("mean").textContent = "-";
        document.getElementById("min").textContent = "-";
        document.getElementById("p25").textContent = "-";
        document.getElementById("median").textContent = "-";
        document.getElementById("p75").textContent = "-";
        document.getElementById("p90").textContent = "-";
        document.getElementById("p95").textContent = "-";
        document.getElementById("max").textContent = "-";
        document.getElementById("stddev").textContent = "-";
        return;
      }
      const min = Math.min(...values);
      const max = Math.max(...values);
      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
      const variance =
        values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
      const stddev = Math.sqrt(variance);
      const sorted = [...values].sort((a, b) => a - b);
      const p25 = quantile(sorted, 0.25);
      const median = quantile(sorted, 0.5);
      const p75 = quantile(sorted, 0.75);
      const p90 = quantile(sorted, 0.9);
      const p95 = quantile(sorted, 0.95);

      document.getElementById("count").textContent = values.length;
      document.getElementById("mean").textContent = formatStat(mean);
      document.getElementById("min").textContent = formatStat(min);
      document.getElementById("p25").textContent = formatStat(p25);
      document.getElementById("median").textContent = formatStat(median);
      document.getElementById("p75").textContent = formatStat(p75);
      document.getElementById("p90").textContent = formatStat(p90);
      document.getElementById("p95").textContent = formatStat(p95);
      document.getElementById("max").textContent = formatStat(max);
      document.getElementById("stddev").textContent = formatStat(stddev);
    };

    const formatBinWidth = (v) => {
      if (!Number.isFinite(v)) return "";
      if (Number.isInteger(v)) return v.toFixed(0);
      const fixed = v.toFixed(4);
      return fixed.replace(/\.?0+$/, "");
    };

    const computeNiceBinWidth = (values) => {
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const n = sorted.length;
      const q1 = quantile(sorted, 0.25);
      const q3 = quantile(sorted, 0.75);
      const iqr = q3 - q1;
      if (!Number.isFinite(iqr) || iqr <= 0) return null;
      const h0 = (2 * iqr) / Math.cbrt(n);
      if (!Number.isFinite(h0) || h0 <= 0) return null;
      const order = Math.pow(10, Math.floor(Math.log10(h0)));
      const scaled = h0 / order;
      let niceScaled = 10;
      if (scaled <= 1.5) niceScaled = 1;
      else if (scaled <= 3) niceScaled = 2;
      else if (scaled <= 7) niceScaled = 5;
      else niceScaled = 10;
      return niceScaled * order;
    };

    const setExcludedCount = (excluded) => {
      const el = document.getElementById("excludedCount");
      if (el) el.textContent = `除外数: ${excluded}`;
    };

    let binWidthTouched = false;
    let filterMinTouched = false;

    const updateRawStats = () => {
      const raw = document.getElementById("dataInput").value;
      const values = parseData(raw);
      updateStats(values);
      setExcludedCount("-");
      if (!binWidthTouched) {
        const nice = computeNiceBinWidth(values);
        if (nice) {
          document.getElementById("binWidth").value = formatBinWidth(nice);
        }
      }
      if (!filterMinTouched) {
        const niceMax = (() => {
          if (values.length === 0) return null;
          const sorted = [...values].sort((a, b) => a - b);
          const q1 = quantile(sorted, 0.25);
          const q3 = quantile(sorted, 0.75);
          const iqr = q3 - q1;
          if (!Number.isFinite(iqr)) return null;
          const cap = q3 + 1.5 * iqr;
          const max = sorted[sorted.length - 1];
          if (cap >= max) return null;
          return cap;
        })();
        const el = document.getElementById("filterMin");
        if (Number.isFinite(niceMax)) {
          el.value = formatBinWidth(niceMax);
        } else {
          el.value = "";
        }
      }
    };

    const buildHistogram = () => {
      const raw = document.getElementById("dataInput").value;
      const binWidth = Number(document.getElementById("binWidth").value);
      const filterMin = document.getElementById("filterMin").value;
      const filterMax = document.getElementById("filterMax").value;
      const splitZero = document.getElementById("splitZero").checked;

      const errorEl = document.getElementById("error");
      errorEl.textContent = "";

      if (!Number.isFinite(binWidth) || binWidth <= 0) {
        errorEl.textContent = "bin の幅は 0 より大きい数値を入力してください。";
        document.getElementById("histChart").innerHTML = "";
        document.getElementById("boxPlot").innerHTML = "";
        setExcludedCount("-");
        return;
      }

      const values = parseData(raw);
      const minVal = filterMin === "" ? NaN : Number(filterMin);
      const maxVal = filterMax === "" ? NaN : Number(filterMax);

      const { filtered, excluded } = applyFilter(values, minVal, maxVal);
      const allInt = filtered.length > 0 && filtered.every((v) => Number.isInteger(v));
      const { bins, zeroCount } = buildBins(filtered, binWidth, splitZero, allInt);
      renderHistogram(bins, zeroCount, binWidth, splitZero, allInt);
      renderBoxPlot(filtered);
      setExcludedCount(excluded);
    };

    const debounce = (fn, wait = 250) => {
      let t = null;
      return (...args) => {
        window.clearTimeout(t);
        t = window.setTimeout(() => fn(...args), wait);
      };
    };

    const debouncedBuild = debounce(buildHistogram, 250);

    document.getElementById("dataInput").addEventListener("input", () => {
      updateRawStats();
      debouncedBuild();
    });
    document.getElementById("binWidth").addEventListener("input", () => {
      binWidthTouched = true;
      debouncedBuild();
    });
    document.getElementById("filterMin").addEventListener("input", () => {
      filterMinTouched = true;
      debouncedBuild();
    });
    document.getElementById("filterMax").addEventListener("input", debouncedBuild);
    document.getElementById("splitZero").addEventListener("change", buildHistogram);

    updateRawStats();
  </script>
</body>
</html>
