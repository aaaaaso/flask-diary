<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Circles and Dogs</title>
    <meta name="description" content="ãƒ©ãƒ³ãƒ€ãƒ ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚«ãƒ©ãƒ•ãƒ«ãªå††ã¨ã€5%ã®ç¢ºçŽ‡ã§å‡ºç¾ã™ã‚‹çŠ¬ã€‚ä»»æ„ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚„ã‚­ãƒ¼ã§éŸ³ãŒé³´ã£ãŸã‚Šã™ã‚‹ã€‚" />
    <style>
      :root {
        color-scheme: light;
      }
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at 20% 20%, #f4f6f8, #d3d9e0 45%, #aeb6c2 100%);
        font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      }
      canvas {
        display: block;
        position: fixed;
        inset: 0;
        z-index: 1;
      }
      #p5_loading {
        display: none !important;
      }
      .sound-toggle {
        position: fixed;
        right: 16px;
        bottom: 14px;
        z-index: 2;
        padding: 8px 14px;
        border: 0;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.85);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        font-size: 13px;
        letter-spacing: 0.04em;
        cursor: pointer;
      }
      .counter {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2;
        display: flex;
        justify-content: center;
        gap: 12px;
        padding: 8px 16px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.78);
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.1);
        font-size: 13px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        max-width: min(92vw, 560px);
      }
      .counter span {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
      }
      .counter b {
        font-weight: 600;
        letter-spacing: 0.04em;
      }
      .control-bar {
        position: fixed;
        top: 62px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0;
        font-size: 12px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        max-width: min(92vw, 560px);
      }
      .scale-select {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .key-select {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .dropdown {
        position: relative;
      }
      .dropdown-toggle {
        border: 0;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 999px;
        padding: 4px 28px 4px 10px;
        font-size: 12px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        cursor: pointer;
        position: relative;
      }
      .dropdown-toggle::after {
        content: "â–¾";
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-48%);
        font-size: 11px;
        opacity: 0.7;
      }
      .dropdown-toggle[aria-disabled="true"] {
        opacity: 0.45;
        filter: grayscale(0.4);
        cursor: not-allowed;
      }
      .dropdown-menu {
        position: absolute;
        top: calc(100% + 6px);
        left: 0;
        min-width: 120px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        box-shadow: 0 14px 26px rgba(0, 0, 0, 0.12);
        padding: 6px;
        list-style: none;
        margin: 0;
        display: none;
        z-index: 3;
      }
      .key-select .dropdown-menu {
        min-width: 72px;
      }
      .dropdown.open .dropdown-menu {
        display: block;
      }
      .dropdown-option {
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 12px;
      }
      .dropdown-option[aria-selected="true"] {
        background: rgba(0, 0, 0, 0.06);
        font-weight: 600;
      }
      .dropdown-option:hover {
        background: rgba(0, 0, 0, 0.05);
      }
      @media (max-width: 600px) {
        .counter {
          top: 10px;
          gap: 8px;
          padding: 8px 12px;
          font-size: 11px;
          letter-spacing: 0.06em;
        }
        .control-bar {
          top: 54px;
          gap: 8px;
          padding: 6px 10px;
          font-size: 12px;
          letter-spacing: 0.05em;
        }
        .counter span {
          gap: 6px;
        }
        .dropdown-toggle {
          padding: 3px 24px 3px 8px;
          font-size: 12px;
        }
        .dropdown-option {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="counter" aria-live="polite">
      <span>Circles <b id="circleCount">0</b></span>
      <span>Dogs <b id="dogCount">0</b></span>
      <span id="dogAltWrap" style="display: none;">DOG?S <b id="dogAltCount">0</b></span>
    </div>
    <div class="control-bar" aria-label="Scale controls">
      <span class="scale-select">
        <label for="scaleSelect">Scale</label>
        <div class="dropdown" id="scaleSelect">
          <button class="dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false">
            Ionian
          </button>
          <ul class="dropdown-menu" role="listbox">
            <li class="dropdown-option" role="option" data-value="ionian" aria-selected="true">Ionian</li>
            <li class="dropdown-option" role="option" data-value="dorian">Dorian</li>
            <li class="dropdown-option" role="option" data-value="phrygian">Phrygian</li>
            <li class="dropdown-option" role="option" data-value="lydian">Lydian</li>
            <li class="dropdown-option" role="option" data-value="mixolydian">Mixolydian</li>
            <li class="dropdown-option" role="option" data-value="aeolian">Aeolian</li>
            <li class="dropdown-option" role="option" data-value="locrian">Locrian</li>
            <li class="dropdown-option" role="option" data-value="random">Random</li>
          </ul>
        </div>
      </span>
      <span class="key-select">
        <label for="keySelect">Key</label>
        <div class="dropdown" id="keySelect">
          <button class="dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false">
            Dâ™­
          </button>
          <ul class="dropdown-menu" role="listbox">
            <li class="dropdown-option" role="option" data-value="C">C</li>
            <li class="dropdown-option" role="option" data-value="Db" aria-selected="true">Dâ™­</li>
            <li class="dropdown-option" role="option" data-value="D">D</li>
            <li class="dropdown-option" role="option" data-value="Eb">Eâ™­</li>
            <li class="dropdown-option" role="option" data-value="E">E</li>
            <li class="dropdown-option" role="option" data-value="F">F</li>
            <li class="dropdown-option" role="option" data-value="Gb">Gâ™­</li>
            <li class="dropdown-option" role="option" data-value="G">G</li>
            <li class="dropdown-option" role="option" data-value="Ab">Aâ™­</li>
            <li class="dropdown-option" role="option" data-value="A">A</li>
            <li class="dropdown-option" role="option" data-value="Bb">Bâ™­</li>
            <li class="dropdown-option" role="option" data-value="B">B</li>
          </ul>
        </div>
      </span>
    </div>
    <button class="sound-toggle" id="soundToggle">ðŸ”Š ON</button>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
    <script>
      const circles = [];
      const effects = [];
      const maxCircles = 120;
      const timeScale = 0.25;
      const spawnIntervalMs = 100;
      const dogChance = 0.05;
      let spawnTimer = 0;
      const softPalette = [
        { h: 210, s: 18, b: 96 },
        { h: 200, s: 22, b: 92 },
        { h: 225, s: 16, b: 90 },
        { h: 190, s: 20, b: 94 },
        { h: 250, s: 14, b: 92 },
        { h: 170, s: 18, b: 90 }
      ];

      let audioCtx = null;
      let masterGain = null;
      const baseFreq = 660;
      let audioEnabled = false;
      let audioUnlocked = false;
      let dogImg = null;
      let dogAudioChoices = [];
      let popBuffer = null;
      let audioBuffersReady = false;
      let circleCount = 0;
      let dogCount = 0;
      let dogAltCount = 0;
      let scaleMode = "ionian";
      let keyRootMidi = 61;
      let lastScaleMidi = null;
      const scaleModes = {
        ionian: [0, 2, 4, 5, 7, 9, 11],
        dorian: [0, 2, 3, 5, 7, 9, 10],
        phrygian: [0, 1, 3, 5, 7, 8, 10],
        lydian: [0, 2, 4, 6, 7, 9, 11],
        mixolydian: [0, 2, 4, 5, 7, 9, 10],
        aeolian: [0, 2, 3, 5, 7, 8, 10],
        locrian: [0, 1, 3, 5, 6, 8, 10]
      };

      function preload() {
        dogImg = loadImage("dog.png");
      }

      function setup() {
        const canvas = createCanvas(windowWidth, windowHeight);
        noStroke();
        colorMode(HSB, 360, 100, 100, 100);
        background(0, 0, 100, 0);
        dogAudioChoices = [
          { url: "dog_voice.mp3", weight: 0.8, type: "dog", buffer: null, volume: 0.336 },
          { url: "guaa.mp3", weight: 0.2, type: "dogAlt", buffer: null, volume: 0.336 }
        ];
        initDropdown("scaleSelect", (value) => {
          scaleMode = value;
          if (scaleMode === "random") {
            lastScaleMidi = null;
          }
          updateKeyAvailability();
        });
        initDropdown("keySelect", (value) => {
          keyRootMidi = keyNameToMidi(value);
        });
        updateKeyAvailability();
        canvas.elt.addEventListener("pointerdown", (event) => {
          if (event.pointerType === "mouse" && event.button !== 0) return;
          const rect = canvas.elt.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          tryTapCircle(x, y);
        });
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }

      function draw() {
        clear();
        background(0, 0, 100, 10);

        const dt = (deltaTime / 16.6667) * timeScale;
        spawnTimer += deltaTime * timeScale;

        if (spawnTimer >= spawnIntervalMs && circles.length < maxCircles) {
          const c = makeCircle();
          circles.push(c);
          playPop(c.freq);
          if (scaleMode !== "random" && c.midi) {
            lastScaleMidi = c.midi;
          }
          spawnTimer = 0;
        }

        for (let i = circles.length - 1; i >= 0; i--) {
          const c = circles[i];
          c.life -= dt;
          c.r += c.grow * dt;
          c.alpha = map(c.life, 0, c.maxLife, 30, 80);
          fill(c.hue, c.sat, c.bri, c.alpha);
          if (c.isDog && dogImg) {
            tint(0, 0, 100, c.alpha);
            image(dogImg, c.x - c.r, c.y - c.r, c.r * 2, c.r * 2);
            noTint();
          } else {
            ellipse(c.x, c.y, c.r * 2);
          }
          if (c.life <= 0) {
            circles.splice(i, 1);
          }
        }

        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.t += dt;
          const progress = e.t / e.maxT;
          const alpha = map(progress, 0, 1, e.alpha, 0);
          const radius = e.r + e.expand * progress;
          noFill();
          stroke(e.hue ?? 210, e.sat ?? 8, e.bri ?? 96, alpha);
          strokeWeight(e.weight || 2);
          ellipse(e.x, e.y, radius * 2);
          if (e.rings === 2) {
            const inner = radius * 0.72;
            ellipse(e.x, e.y, inner * 2);
          }
          if (progress >= 1) {
            effects.splice(i, 1);
          }
        }
        noStroke();
      }

      function makeCircle() {
        const r = random(10, 60);
        const isDog = random() < dogChance;
        const tone = pickSoftColor();
        const pitch = sizeToPitch(r);
        return {
          x: random(width),
          y: random(height),
          r,
          grow: random(0.2, 1.6),
          hue: tone.h,
          sat: tone.s,
          bri: tone.b,
          alpha: 90,
          maxLife: int(random(60, 180)),
          life: int(random(60, 180)),
          freq: pitch.freq,
          midi: pitch.midi,
          isDog
        };
      }

      function pickSoftColor() {
        const base = random(softPalette);
        return {
          h: (base.h + random(-6, 6) + 360) % 360,
          s: constrain(base.s + random(-4, 4), 10, 30),
          b: constrain(base.b + random(-4, 4), 82, 98)
        };
      }

      function sizeToPitch(r) {
        // smaller circle -> higher pitch
        const raw = map(r, 10, 60, 560, 140);
        if (scaleMode === "random") {
          return { freq: raw, midi: null };
        }
        const midi = quantizeToScaleMidi(raw, scaleMode);
        return { freq: midiToFreq(midi), midi };
      }

      function quantizeToScaleMidi(freq, mode) {
        const steps = scaleModes[mode];
        if (!steps) return freqToMidi(freq);
        const minMidi = 48;
        const maxMidi = 84;
        const candidates = [];
        for (let m = minMidi; m <= maxMidi; m++) {
          const degree = (m - keyRootMidi + 1200) % 12;
          if (steps.includes(degree)) {
            candidates.push(m);
          }
        }
        let best = candidates[0];
        let bestDiff = Math.abs(freq - midiToFreq(best));
        for (let i = 1; i < candidates.length; i++) {
          const diff = Math.abs(freq - midiToFreq(candidates[i]));
          if (diff < bestDiff) {
            bestDiff = diff;
            best = candidates[i];
          }
        }
        return best ?? freqToMidi(freq);
      }

      function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }

      function freqToMidi(freq) {
        return Math.round(69 + 12 * Math.log2(freq / 440));
      }

      function keyNameToMidi(name) {
        const keyMap = {
          C: 60,
          Db: 61,
          D: 62,
          Eb: 63,
          E: 64,
          F: 65,
          Gb: 66,
          G: 67,
          Ab: 68,
          A: 69,
          Bb: 70,
          B: 71
        };
        return keyMap[name] ?? 61;
      }

      function updateKeyAvailability() {
        const keySelect = document.getElementById("keySelect");
        if (!keySelect) return;
        const toggle = keySelect.querySelector(".dropdown-toggle");
        if (!toggle) return;
        const disabled = scaleMode === "random";
        toggle.setAttribute("aria-disabled", disabled ? "true" : "false");
        if (disabled) {
          keySelect.classList.remove("open");
        }
      }

      function initDropdown(id, onChange) {
        const root = document.getElementById(id);
        if (!root) return;
        const toggle = root.querySelector(".dropdown-toggle");
        const menu = root.querySelector(".dropdown-menu");
        const options = Array.from(root.querySelectorAll(".dropdown-option"));
        if (!toggle || !menu || options.length === 0) return;

        const selectValue = (value) => {
          const option = options.find((opt) => opt.dataset.value === value) || options[0];
          options.forEach((opt) => opt.setAttribute("aria-selected", opt === option ? "true" : "false"));
          toggle.textContent = option.textContent;
          toggle.setAttribute("aria-expanded", "false");
          root.classList.remove("open");
          onChange(option.dataset.value);
        };

        options.forEach((opt) => {
          opt.addEventListener("click", (event) => {
            event.stopPropagation();
            selectValue(opt.dataset.value);
          });
        });

        toggle.addEventListener("click", (event) => {
          event.stopPropagation();
          if (toggle.getAttribute("aria-disabled") === "true") return;
          const open = root.classList.toggle("open");
          toggle.setAttribute("aria-expanded", open ? "true" : "false");
        });

        document.addEventListener("click", () => {
          root.classList.remove("open");
          toggle.setAttribute("aria-expanded", "false");
        });

        selectValue(options.find((opt) => opt.getAttribute("aria-selected") === "true")?.dataset.value || "ionian");
      }

      function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.35;
        masterGain.connect(audioCtx.destination);
        audioEnabled = true;
        updateSoundButton();
        ensureAudioBuffers();
      }

      function playPop(freq) {
        if (!audioEnabled || !audioCtx) return;
        if (audioCtx.state !== "running") return;
        const now = audioCtx.currentTime;
        const oscA = audioCtx.createOscillator();
        const oscB = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        const f = freq || baseFreq;
        oscA.type = "triangle";
        oscB.type = "sine";
        oscA.frequency.value = f;
        oscB.frequency.value = f * 1.005;

        filter.type = "lowpass";
        filter.frequency.value = 2400;
        filter.Q.value = 0.7;

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);

        oscA.connect(filter);
        oscB.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        oscA.start(now);
        oscB.start(now);
        oscA.stop(now + 0.75);
        oscB.stop(now + 0.75);
      }

      function playMetallic(freq) {
        if (!audioEnabled || !audioUnlocked || !popBuffer || !audioCtx) return;
        try {
          playBuffer(popBuffer, 0.288);
        } catch (e) {
          // no-op: some browsers may block playback
        }
      }

      function playScaleChord(notes, variant) {
        if (!audioEnabled || !audioUnlocked || !audioCtx) return;
        if (audioCtx.state !== "running") return;
        if (!notes || notes.length === 0) return;
        const adjusted = adjustChordOctave(notes, variant);
        const freqs = adjusted.map(midiToFreq);
        const now = audioCtx.currentTime;
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        filter.type = "lowpass";
        filter.frequency.value = 1500;
        filter.Q.value = 0.8;

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.09, now + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);

        const oscillators = freqs.map((freq, index) => {
          const osc = audioCtx.createOscillator();
          osc.type = index === 0 ? "triangle" : "sine";
          osc.frequency.value = freq;
          osc.connect(filter);
          return osc;
        });
        filter.connect(gain);
        gain.connect(masterGain);

        oscillators.forEach((osc) => {
          osc.start(now);
          osc.stop(now + 0.8);
        });
      }

      function adjustChordOctave(notes, variant) {
        if (variant === "triad") return notes;
        const lowest = Math.min(...notes);
        if (lowest < 60) {
          return notes.map((m) => m + 12);
        }
        return notes;
      }

      function buildScaleChord(rootMidi, count) {
        if (count && count % 100 === 0) {
          return {
            notes: [
              rootMidi,
              shiftScaleDegree(rootMidi, 4),
              shiftScaleDegree(rootMidi, 6),
              shiftScaleDegree(rootMidi, 10)
            ],
            variant: "eleventh"
          };
        }
        if (count && count % 10 === 0) {
          const roll = random();
          if (roll < 0.25) {
            return {
              notes: [
                rootMidi,
                shiftScaleDegree(rootMidi, 1),
                shiftScaleDegree(rootMidi, 4)
              ],
              variant: "sus2"
            };
          }
          if (roll < 0.5) {
            return {
              notes: [
                rootMidi,
                shiftScaleDegree(rootMidi, 3),
                shiftScaleDegree(rootMidi, 4)
              ],
              variant: "sus4"
            };
          }
          if (roll < 0.75) {
            return {
              notes: [
                shiftScaleDegree(rootMidi, 1),
                shiftScaleDegree(rootMidi, 4),
                shiftScaleDegree(rootMidi, 6)
              ],
              variant: "noRoot257"
            };
          }
          return {
            notes: [
              rootMidi,
              shiftScaleDegree(rootMidi, 2),
              shiftScaleDegree(rootMidi, 4),
              shiftScaleDegree(rootMidi, 8)
            ],
            variant: "add9"
          };
        }
        if (count && count % 7 === 0) {
          const useInversion = random() < 0.5;
          if (useInversion) {
            return {
              notes: [
                shiftScaleDegree(rootMidi, 2),
                shiftScaleDegree(rootMidi, 4),
                shiftScaleDegree(rootMidi, 6)
              ],
              variant: "invA"
            };
          }
          return {
            notes: [
              rootMidi,
              shiftScaleDegree(rootMidi, 2),
              shiftScaleDegree(rootMidi, 4),
              shiftScaleDegree(rootMidi, 6)
            ],
            variant: "seventh"
          };
        }
        return {
          notes: [
            rootMidi,
            shiftScaleDegree(rootMidi, 2),
            shiftScaleDegree(rootMidi, 4)
          ],
          variant: "triad"
        };
      }

      function shiftScaleDegree(midi, degreeSteps) {
        let current = midi;
        let count = 0;
        while (count < degreeSteps) {
          current += 1;
          if (isScaleTone(current)) {
            count += 1;
          }
        }
        return current;
      }

      function isScaleTone(midi) {
        const steps = scaleModes[scaleMode];
        if (!steps) return false;
        const degree = (midi - keyRootMidi + 1200) % 12;
        return steps.includes(degree);
      }

      function playDog() {
        if (!audioEnabled || !audioUnlocked || dogAudioChoices.length === 0) return;
        try {
          const picked = pickDogAudio();
          if (!picked) return;
          playBuffer(picked.buffer, picked.volume ?? 0.56);
          return picked.type;
        } catch (e) {
          // no-op: some browsers may block playback
        }
      }

      function pickDogAudio() {
        const roll = random();
        let acc = 0;
        for (let i = 0; i < dogAudioChoices.length; i++) {
          acc += dogAudioChoices[i].weight;
          if (roll <= acc) {
            const entry = dogAudioChoices[i];
            if (!entry.buffer) return null;
            return { buffer: entry.buffer, type: entry.type, volume: entry.volume };
          }
        }
        return null;
      }

      async function ensureAudioBuffers() {
        if (!audioCtx || audioBuffersReady) return;
        try {
          popBuffer = await loadAudioBuffer("pon.mp3");
          await Promise.all(
            dogAudioChoices.map(async (entry) => {
              entry.buffer = await loadAudioBuffer(entry.url);
            })
          );
          audioBuffersReady = true;
        } catch (e) {
          // no-op: keep silent if loading fails
        }
      }

      async function loadAudioBuffer(url) {
        const res = await fetch(url);
        const data = await res.arrayBuffer();
        return await audioCtx.decodeAudioData(data);
      }

      function playBuffer(buffer, volume) {
        if (!audioCtx || !buffer || !masterGain) return;
        const source = audioCtx.createBufferSource();
        const gain = audioCtx.createGain();
        gain.gain.value = volume;
        source.buffer = buffer;
        source.connect(gain);
        gain.connect(masterGain);
        source.start();
      }

      function addEffect(x, y, r, variant = "triad") {
        const styleMap = {
          triad: { alpha: 70, expand: 2.2, weight: 1.8, hue: 210, sat: 8, bri: 96, rings: 1 },
          seventh: { alpha: 80, expand: 2.8, weight: 2.4, hue: 200, sat: 12, bri: 98, rings: 2 },
          sus2: { alpha: 76, expand: 2.3, weight: 2, hue: 185, sat: 10, bri: 98, rings: 2 },
          sus4: { alpha: 76, expand: 2.3, weight: 2, hue: 235, sat: 10, bri: 98, rings: 2 },
          add9: { alpha: 78, expand: 2.55, weight: 2.1, hue: 215, sat: 14, bri: 99, rings: 2 },
          noRoot257: { alpha: 72, expand: 2.2, weight: 1.8, hue: 200, sat: 8, bri: 96, rings: 2 },
          invA: { alpha: 68, expand: 2.05, weight: 1.7, hue: 220, sat: 6, bri: 94, rings: 2 },
          eleventh: { alpha: 92, expand: 3.25, weight: 2.7, hue: 210, sat: 55, bri: 98, rings: 2 }
        };
        const style = styleMap[variant] || styleMap.triad;
        effects.push({
          x,
          y,
          r: r * 0.7,
          expand: r * style.expand,
          alpha: style.alpha,
          weight: style.weight,
          hue: style.hue,
          sat: style.sat,
          bri: style.bri,
          rings: style.rings,
          t: 0,
          maxT: 18
        });
      }

      function tryTapCircle(x, y) {
        for (let i = 0; i < circles.length; i++) {
          const c = circles[i];
          const d = dist(x, y, c.x, c.y);
          if (d > c.r) continue;
          if (c.isDog) {
            const played = playDog();
            if (played === "dogAlt") {
              dogAltCount += 1;
              updateDogAltVisibility();
            } else {
              dogCount += 1;
            }
          } else {
            if (scaleMode === "random") {
              playMetallic(c.freq);
            } else {
              const rootMidi = lastScaleMidi ?? c.midi ?? quantizeToScaleMidi(c.freq, scaleMode);
              const nextCount = circleCount + 1;
              const chord = buildScaleChord(rootMidi, nextCount);
              playScaleChord(chord.notes, chord.variant);
              circleCount = nextCount;
              updateCounters();
              addEffect(c.x, c.y, c.r, chord.variant);
              circles.splice(i, 1);
              break;
            }
          }
          if (!c.isDog) {
            circleCount += 1;
          }
          updateCounters();
          addEffect(c.x, c.y, c.r);
          circles.splice(i, 1);
          break;
        }
      }

      function updateCounters() {
        const circleEl = document.getElementById("circleCount");
        const dogEl = document.getElementById("dogCount");
        const dogAltEl = document.getElementById("dogAltCount");
        if (circleEl) circleEl.textContent = String(circleCount);
        if (dogEl) dogEl.textContent = String(dogCount);
        if (dogAltEl) dogAltEl.textContent = String(dogAltCount);
      }

      function updateDogAltVisibility() {
        const wrap = document.getElementById("dogAltWrap");
        if (!wrap) return;
        if (dogAltCount > 0) {
          wrap.style.display = "inline-flex";
        }
      }

      function updateSoundButton() {
        const btn = document.getElementById("soundToggle");
        if (!btn) return;
        if (!audioUnlocked) {
          btn.textContent = "ðŸ”Š ON";
          return;
        }
        btn.textContent = audioEnabled ? "ðŸ”Š ON" : "ðŸ”‡ OFF";
      }


      async function unlockAudio() {
        if (!audioCtx) {
          initAudio();
        }
        if (audioCtx && audioCtx.state === "suspended") {
          await audioCtx.resume();
        }
        if (audioCtx && audioCtx.state === "running") {
          audioUnlocked = true;
          audioEnabled = true;
          updateSoundButton();
          await ensureAudioBuffers();
          playPop();
        }
      }

      document.getElementById("soundToggle").addEventListener("click", async () => {
        if (!audioUnlocked) {
          await unlockAudio();
          return;
        }
        audioEnabled = !audioEnabled;
        if (audioCtx) {
          if (audioEnabled && audioCtx.state === "suspended") {
            await audioCtx.resume();
          }
          if (!audioEnabled && audioCtx.state === "running") {
            await audioCtx.suspend();
          }
        }
        updateSoundButton();
      });

      window.addEventListener("pointerdown", () => {
        if (!audioUnlocked) {
          unlockAudio();
        }
      }, { once: true });
    </script>
  </body>
</html>
