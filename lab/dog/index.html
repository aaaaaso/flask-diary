<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Colorful Pop Circles</title>
    <style>
      :root {
        color-scheme: light;
      }
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at 20% 20%, #f4f6f8, #d3d9e0 45%, #aeb6c2 100%);
        font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      }
      canvas {
        display: block;
        position: fixed;
        inset: 0;
        z-index: 1;
      }
      .sound-toggle {
        position: fixed;
        right: 16px;
        bottom: 14px;
        z-index: 2;
        padding: 8px 14px;
        border: 0;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.85);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        font-size: 13px;
        letter-spacing: 0.04em;
        cursor: pointer;
      }
      .counter {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2;
        display: flex;
        justify-content: center;
        gap: 12px;
        padding: 8px 16px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.78);
        box-shadow: 0 8px 26px rgba(0, 0, 0, 0.1);
        font-size: 13px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        max-width: min(92vw, 560px);
      }
      .counter span {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
      }
      .counter b {
        font-weight: 600;
        letter-spacing: 0.04em;
      }
      .control-bar {
        position: fixed;
        top: 62px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0;
        font-size: 12px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        max-width: min(92vw, 560px);
      }
      .scale-select {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .key-select {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .dropdown {
        position: relative;
      }
      .dropdown-toggle {
        border: 0;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 999px;
        padding: 4px 28px 4px 10px;
        font-size: 12px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        cursor: pointer;
        position: relative;
      }
      .dropdown-toggle::after {
        content: "â–¾";
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-48%);
        font-size: 11px;
        opacity: 0.7;
      }
      .dropdown-toggle[aria-disabled="true"] {
        opacity: 0.45;
        filter: grayscale(0.4);
        cursor: not-allowed;
      }
      .dropdown-menu {
        position: absolute;
        top: calc(100% + 6px);
        left: 0;
        min-width: 120px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        box-shadow: 0 14px 26px rgba(0, 0, 0, 0.12);
        padding: 6px;
        list-style: none;
        margin: 0;
        display: none;
        z-index: 3;
      }
      .key-select .dropdown-menu {
        min-width: 72px;
      }
      .dropdown.open .dropdown-menu {
        display: block;
      }
      .dropdown-option {
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 12px;
      }
      .dropdown-option[aria-selected="true"] {
        background: rgba(0, 0, 0, 0.06);
        font-weight: 600;
      }
      .dropdown-option:hover {
        background: rgba(0, 0, 0, 0.05);
      }
      @media (max-width: 600px) {
        .counter {
          top: 10px;
          gap: 8px;
          padding: 8px 12px;
          font-size: 11px;
          letter-spacing: 0.06em;
        }
        .control-bar {
          top: 54px;
          gap: 8px;
          padding: 6px 10px;
          font-size: 12px;
          letter-spacing: 0.05em;
        }
        .counter span {
          gap: 6px;
        }
        .dropdown-toggle {
          padding: 3px 24px 3px 8px;
          font-size: 12px;
        }
        .dropdown-option {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="counter" aria-live="polite">
      <span>Circles <b id="circleCount">0</b></span>
      <span>Dogs <b id="dogCount">0</b></span>
      <span id="dogAltWrap" style="display: none;">DOG?S <b id="dogAltCount">0</b></span>
    </div>
    <div class="control-bar" aria-label="Scale controls">
      <span class="scale-select">
        <label for="scaleSelect">Scale</label>
        <div class="dropdown" id="scaleSelect">
          <button class="dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false">
            Random
          </button>
          <ul class="dropdown-menu" role="listbox">
            <li class="dropdown-option" role="option" data-value="random" aria-selected="true">Random</li>
            <li class="dropdown-option" role="option" data-value="ionian">Ionian</li>
            <li class="dropdown-option" role="option" data-value="dorian">Dorian</li>
            <li class="dropdown-option" role="option" data-value="phrygian">Phrygian</li>
            <li class="dropdown-option" role="option" data-value="lydian">Lydian</li>
            <li class="dropdown-option" role="option" data-value="mixolydian">Mixolydian</li>
            <li class="dropdown-option" role="option" data-value="aeolian">Aeolian</li>
            <li class="dropdown-option" role="option" data-value="locrian">Locrian</li>
          </ul>
        </div>
      </span>
      <span class="key-select">
        <label for="keySelect">Key</label>
        <div class="dropdown" id="keySelect">
          <button class="dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false">
            Dâ™­
          </button>
          <ul class="dropdown-menu" role="listbox">
            <li class="dropdown-option" role="option" data-value="C">C</li>
            <li class="dropdown-option" role="option" data-value="Db" aria-selected="true">Dâ™­</li>
            <li class="dropdown-option" role="option" data-value="D">D</li>
            <li class="dropdown-option" role="option" data-value="Eb">Eâ™­</li>
            <li class="dropdown-option" role="option" data-value="E">E</li>
            <li class="dropdown-option" role="option" data-value="F">F</li>
            <li class="dropdown-option" role="option" data-value="Gb">Gâ™­</li>
            <li class="dropdown-option" role="option" data-value="G">G</li>
            <li class="dropdown-option" role="option" data-value="Ab">Aâ™­</li>
            <li class="dropdown-option" role="option" data-value="A">A</li>
            <li class="dropdown-option" role="option" data-value="Bb">Bâ™­</li>
            <li class="dropdown-option" role="option" data-value="B">B</li>
          </ul>
        </div>
      </span>
    </div>
    <button class="sound-toggle" id="soundToggle">ðŸ”Š ON</button>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
    <script>
      const circles = [];
      const effects = [];
      const maxCircles = 120;
      const timeScale = 0.25;
      const spawnIntervalMs = 100;
      const dogChance = 0.05;
      let spawnTimer = 0;
      const softPalette = [
        { h: 210, s: 18, b: 96 },
        { h: 200, s: 22, b: 92 },
        { h: 225, s: 16, b: 90 },
        { h: 190, s: 20, b: 94 },
        { h: 250, s: 14, b: 92 },
        { h: 170, s: 18, b: 90 }
      ];

      let audioCtx = null;
      let masterGain = null;
      const baseFreq = 660;
      let audioEnabled = false;
      let audioUnlocked = false;
      let dogImg = null;
      let dogAudioChoices = [];
      let popBuffer = null;
      let audioBuffersReady = false;
      let circleCount = 0;
      let dogCount = 0;
      let dogAltCount = 0;
      let scaleMode = "random";
      let keyRootMidi = 61;
      let lastScaleMidi = null;
      const scaleModes = {
        ionian: [0, 2, 4, 5, 7, 9, 11],
        dorian: [0, 2, 3, 5, 7, 9, 10],
        phrygian: [0, 1, 3, 5, 7, 8, 10],
        lydian: [0, 2, 4, 6, 7, 9, 11],
        mixolydian: [0, 2, 4, 5, 7, 9, 10],
        aeolian: [0, 2, 3, 5, 7, 8, 10],
        locrian: [0, 1, 3, 5, 6, 8, 10]
      };

      function preload() {
        dogImg = loadImage("dog.png");
      }

      function setup() {
        const canvas = createCanvas(windowWidth, windowHeight);
        noStroke();
        colorMode(HSB, 360, 100, 100, 100);
        background(0, 0, 100, 0);
        dogAudioChoices = [
          { url: "dog_voice.mp3", weight: 0.8, type: "dog", buffer: null },
          { url: "guaa.mp3", weight: 0.2, type: "dogAlt", buffer: null }
        ];
        initDropdown("scaleSelect", (value) => {
          scaleMode = value;
          if (scaleMode === "random") {
            lastScaleMidi = null;
          }
          updateKeyAvailability();
        });
        initDropdown("keySelect", (value) => {
          keyRootMidi = keyNameToMidi(value);
        });
        updateKeyAvailability();
        canvas.elt.addEventListener("pointerdown", (event) => {
          if (event.pointerType === "mouse" && event.button !== 0) return;
          const rect = canvas.elt.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          tryTapCircle(x, y);
        });
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }

      function draw() {
        clear();
        background(0, 0, 100, 10);

        const dt = (deltaTime / 16.6667) * timeScale;
        spawnTimer += deltaTime * timeScale;

        if (spawnTimer >= spawnIntervalMs && circles.length < maxCircles) {
          const c = makeCircle();
          circles.push(c);
          playPop(c.freq);
          if (scaleMode !== "random" && c.midi) {
            lastScaleMidi = c.midi;
          }
          spawnTimer = 0;
        }

        for (let i = circles.length - 1; i >= 0; i--) {
          const c = circles[i];
          c.life -= dt;
          c.r += c.grow * dt;
          c.alpha = map(c.life, 0, c.maxLife, 20, 80);
          fill(c.hue, c.sat, c.bri, c.alpha);
          if (c.isDog && dogImg) {
            tint(0, 0, 100, c.alpha);
            image(dogImg, c.x - c.r, c.y - c.r, c.r * 2, c.r * 2);
            noTint();
          } else {
            ellipse(c.x, c.y, c.r * 2);
          }
          if (c.life <= 0) {
            circles.splice(i, 1);
          }
        }

        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.t += dt;
          const progress = e.t / e.maxT;
          const alpha = map(progress, 0, 1, e.alpha, 0);
          const radius = e.r + e.expand * progress;
          noFill();
          stroke(210, 8, 96, alpha);
          strokeWeight(2);
          ellipse(e.x, e.y, radius * 2);
          if (progress >= 1) {
            effects.splice(i, 1);
          }
        }
        noStroke();
      }

      function makeCircle() {
        const r = random(10, 60);
        const isDog = random() < dogChance;
        const tone = pickSoftColor();
        const pitch = sizeToPitch(r);
        return {
          x: random(width),
          y: random(height),
          r,
          grow: random(0.2, 1.6),
          hue: tone.h,
          sat: tone.s,
          bri: tone.b,
          alpha: 90,
          maxLife: int(random(60, 180)),
          life: int(random(60, 180)),
          freq: pitch.freq,
          midi: pitch.midi,
          isDog
        };
      }

      function pickSoftColor() {
        const base = random(softPalette);
        return {
          h: (base.h + random(-6, 6) + 360) % 360,
          s: constrain(base.s + random(-4, 4), 10, 30),
          b: constrain(base.b + random(-4, 4), 82, 98)
        };
      }

      function sizeToPitch(r) {
        // smaller circle -> higher pitch
        const raw = map(r, 10, 60, 560, 140);
        if (scaleMode === "random") {
          return { freq: raw, midi: null };
        }
        const midi = quantizeToScaleMidi(raw, scaleMode);
        return { freq: midiToFreq(midi), midi };
      }

      function quantizeToScaleMidi(freq, mode) {
        const steps = scaleModes[mode];
        if (!steps) return freqToMidi(freq);
        const minMidi = 48;
        const maxMidi = 84;
        const candidates = [];
        for (let m = minMidi; m <= maxMidi; m++) {
          const degree = (m - keyRootMidi + 1200) % 12;
          if (steps.includes(degree)) {
            candidates.push(m);
          }
        }
        let best = candidates[0];
        let bestDiff = Math.abs(freq - midiToFreq(best));
        for (let i = 1; i < candidates.length; i++) {
          const diff = Math.abs(freq - midiToFreq(candidates[i]));
          if (diff < bestDiff) {
            bestDiff = diff;
            best = candidates[i];
          }
        }
        return best ?? freqToMidi(freq);
      }

      function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }

      function freqToMidi(freq) {
        return Math.round(69 + 12 * Math.log2(freq / 440));
      }

      function keyNameToMidi(name) {
        const keyMap = {
          C: 60,
          Db: 61,
          D: 62,
          Eb: 63,
          E: 64,
          F: 65,
          Gb: 66,
          G: 67,
          Ab: 68,
          A: 69,
          Bb: 70,
          B: 71
        };
        return keyMap[name] ?? 61;
      }

      function updateKeyAvailability() {
        const keySelect = document.getElementById("keySelect");
        if (!keySelect) return;
        const toggle = keySelect.querySelector(".dropdown-toggle");
        if (!toggle) return;
        const disabled = scaleMode === "random";
        toggle.setAttribute("aria-disabled", disabled ? "true" : "false");
        if (disabled) {
          keySelect.classList.remove("open");
        }
      }

      function initDropdown(id, onChange) {
        const root = document.getElementById(id);
        if (!root) return;
        const toggle = root.querySelector(".dropdown-toggle");
        const menu = root.querySelector(".dropdown-menu");
        const options = Array.from(root.querySelectorAll(".dropdown-option"));
        if (!toggle || !menu || options.length === 0) return;

        const selectValue = (value) => {
          const option = options.find((opt) => opt.dataset.value === value) || options[0];
          options.forEach((opt) => opt.setAttribute("aria-selected", opt === option ? "true" : "false"));
          toggle.textContent = option.textContent;
          toggle.setAttribute("aria-expanded", "false");
          root.classList.remove("open");
          onChange(option.dataset.value);
        };

        options.forEach((opt) => {
          opt.addEventListener("click", (event) => {
            event.stopPropagation();
            selectValue(opt.dataset.value);
          });
        });

        toggle.addEventListener("click", (event) => {
          event.stopPropagation();
          if (toggle.getAttribute("aria-disabled") === "true") return;
          const open = root.classList.toggle("open");
          toggle.setAttribute("aria-expanded", open ? "true" : "false");
        });

        document.addEventListener("click", () => {
          root.classList.remove("open");
          toggle.setAttribute("aria-expanded", "false");
        });

        selectValue(options.find((opt) => opt.getAttribute("aria-selected") === "true")?.dataset.value || options[0].dataset.value);
      }

      function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.35;
        masterGain.connect(audioCtx.destination);
        audioEnabled = true;
        updateSoundButton();
        ensureAudioBuffers();
      }

      function playPop(freq) {
        if (!audioEnabled || !audioCtx) return;
        if (audioCtx.state !== "running") return;
        const now = audioCtx.currentTime;
        const oscA = audioCtx.createOscillator();
        const oscB = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        const f = freq || baseFreq;
        oscA.type = "triangle";
        oscB.type = "sine";
        oscA.frequency.value = f;
        oscB.frequency.value = f * 1.005;

        filter.type = "lowpass";
        filter.frequency.value = 2400;
        filter.Q.value = 0.7;

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);

        oscA.connect(filter);
        oscB.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        oscA.start(now);
        oscB.start(now);
        oscA.stop(now + 0.75);
        oscB.stop(now + 0.75);
      }

      function playMetallic(freq) {
        if (!audioEnabled || !audioUnlocked || !popBuffer || !audioCtx) return;
        try {
          playBuffer(popBuffer, 0.6);
        } catch (e) {
          // no-op: some browsers may block playback
        }
      }

      function playScaleChord(rootMidi) {
        if (!audioEnabled || !audioUnlocked || !audioCtx) return;
        if (audioCtx.state !== "running") return;
        const steps = scaleModes[scaleMode];
        if (!steps) return;
        const root = rootMidi;
        const third = shiftScaleDegree(root, 2);
        const fifth = shiftScaleDegree(root, 4);
        const freqs = [root, third, fifth].map(midiToFreq);
        const now = audioCtx.currentTime;
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        filter.type = "lowpass";
        filter.frequency.value = 1500;
        filter.Q.value = 0.8;

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.09, now + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);

        const oscA = audioCtx.createOscillator();
        const oscB = audioCtx.createOscillator();
        const oscC = audioCtx.createOscillator();
        oscA.type = "triangle";
        oscB.type = "sine";
        oscC.type = "sine";
        oscA.frequency.value = freqs[0];
        oscB.frequency.value = freqs[1];
        oscC.frequency.value = freqs[2];

        oscA.connect(filter);
        oscB.connect(filter);
        oscC.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        oscA.start(now);
        oscB.start(now);
        oscC.start(now);
        oscA.stop(now + 0.8);
        oscB.stop(now + 0.8);
        oscC.stop(now + 0.8);
      }

      function shiftScaleDegree(midi, degreeSteps) {
        let current = midi;
        let count = 0;
        while (count < degreeSteps) {
          current += 1;
          if (isScaleTone(current)) {
            count += 1;
          }
        }
        return current;
      }

      function isScaleTone(midi) {
        const steps = scaleModes[scaleMode];
        if (!steps) return false;
        const degree = (midi - keyRootMidi + 1200) % 12;
        return steps.includes(degree);
      }

      function playDog() {
        if (!audioEnabled || !audioUnlocked || dogAudioChoices.length === 0) return;
        try {
          const picked = pickDogAudio();
          if (!picked) return;
          playBuffer(picked.buffer, 0.7);
          return picked.type;
        } catch (e) {
          // no-op: some browsers may block playback
        }
      }

      function pickDogAudio() {
        const roll = random();
        let acc = 0;
        for (let i = 0; i < dogAudioChoices.length; i++) {
          acc += dogAudioChoices[i].weight;
          if (roll <= acc) {
            const entry = dogAudioChoices[i];
            if (!entry.buffer) return null;
            return { buffer: entry.buffer, type: entry.type };
          }
        }
        return null;
      }

      async function ensureAudioBuffers() {
        if (!audioCtx || audioBuffersReady) return;
        try {
          popBuffer = await loadAudioBuffer("pon.mp3");
          await Promise.all(
            dogAudioChoices.map(async (entry) => {
              entry.buffer = await loadAudioBuffer(entry.url);
            })
          );
          audioBuffersReady = true;
        } catch (e) {
          // no-op: keep silent if loading fails
        }
      }

      async function loadAudioBuffer(url) {
        const res = await fetch(url);
        const data = await res.arrayBuffer();
        return await audioCtx.decodeAudioData(data);
      }

      function playBuffer(buffer, volume) {
        if (!audioCtx || !buffer || !masterGain) return;
        const source = audioCtx.createBufferSource();
        const gain = audioCtx.createGain();
        gain.gain.value = volume;
        source.buffer = buffer;
        source.connect(gain);
        gain.connect(masterGain);
        source.start();
      }

      function addEffect(x, y, r) {
        effects.push({
          x,
          y,
          r: r * 0.7,
          expand: r * 2.2,
          alpha: 70,
          t: 0,
          maxT: 18
        });
      }

      function tryTapCircle(x, y) {
        for (let i = 0; i < circles.length; i++) {
          const c = circles[i];
          const d = dist(x, y, c.x, c.y);
          if (d > c.r) continue;
          if (c.isDog) {
            const played = playDog();
            if (played === "dogAlt") {
              dogAltCount += 1;
              updateDogAltVisibility();
            } else {
              dogCount += 1;
            }
          } else {
            if (scaleMode === "random") {
              playMetallic(c.freq);
            } else {
              const rootMidi = lastScaleMidi ?? c.midi ?? quantizeToScaleMidi(c.freq, scaleMode);
              playScaleChord(rootMidi);
            }
            circleCount += 1;
          }
          updateCounters();
          addEffect(c.x, c.y, c.r);
          circles.splice(i, 1);
          break;
        }
      }

      function updateCounters() {
        const circleEl = document.getElementById("circleCount");
        const dogEl = document.getElementById("dogCount");
        const dogAltEl = document.getElementById("dogAltCount");
        if (circleEl) circleEl.textContent = String(circleCount);
        if (dogEl) dogEl.textContent = String(dogCount);
        if (dogAltEl) dogAltEl.textContent = String(dogAltCount);
      }

      function updateDogAltVisibility() {
        const wrap = document.getElementById("dogAltWrap");
        if (!wrap) return;
        if (dogAltCount > 0) {
          wrap.style.display = "inline-flex";
        }
      }

      function updateSoundButton() {
        const btn = document.getElementById("soundToggle");
        if (!btn) return;
        if (!audioUnlocked) {
          btn.textContent = "ðŸ”Š ON";
          return;
        }
        btn.textContent = audioEnabled ? "ðŸ”Š ON" : "ðŸ”‡ OFF";
      }


      async function unlockAudio() {
        if (!audioCtx) {
          initAudio();
        }
        if (audioCtx && audioCtx.state === "suspended") {
          await audioCtx.resume();
        }
        if (audioCtx && audioCtx.state === "running") {
          audioUnlocked = true;
          audioEnabled = true;
          updateSoundButton();
          await ensureAudioBuffers();
          playPop();
        }
      }

      document.getElementById("soundToggle").addEventListener("click", async () => {
        if (!audioUnlocked) {
          await unlockAudio();
          return;
        }
        audioEnabled = !audioEnabled;
        if (audioCtx) {
          if (audioEnabled && audioCtx.state === "suspended") {
            await audioCtx.resume();
          }
          if (!audioEnabled && audioCtx.state === "running") {
            await audioCtx.suspend();
          }
        }
        updateSoundButton();
      });

      window.addEventListener("pointerdown", () => {
        if (!audioUnlocked) {
          unlockAudio();
        }
      }, { once: true });
    </script>
  </body>
</html>
