<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scatter plot</title>
  <meta name="description" content="データを雑にコピペして散布図を書く">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f3f4f6;
      --ink: #1f2328;
      --accent: #3b3f45;
      --accent-2: #8f98a3;
      --card: #ffffff;
      --muted: #6b7280;
      --ring: rgba(31, 35, 40, 0.1);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background:
        radial-gradient(1200px 500px at 10% -10%, rgba(31,35,40,0.08), transparent 60%),
        radial-gradient(900px 400px at 110% 10%, rgba(143,152,163,0.12), transparent 60%),
        var(--bg);
      color: var(--ink);
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      min-height: 100dvh;
    }

    header {
      padding: 36px 22px 12px;
      max-width: 980px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: 0.02em;
      font-size: clamp(28px, 3vw, 40px);
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 12px 22px 60px;
      display: grid;
      gap: 18px;
    }

    .panel {
      background: var(--card);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 18px 50px rgba(31, 28, 23, 0.08);
      border: 1px solid var(--ring);
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="number"],
    input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 16px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
    }

    select {
      width: 100%;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 16px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
    }

    textarea {
      width: 100%;
      min-height: 180px;
      padding: 12px 14px;
      border-radius: 6px;
      border: 1px solid var(--ring);
      background: white;
      font-size: 14px;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      resize: vertical;
    }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
      margin-right: 12px;
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .stats-table th,
    .stats-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--ring);
      text-align: left;
    }

    .stats-table th {
      font-weight: 700;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .error {
      color: #b42318;
      font-size: 13px;
      margin-top: 8px;
      min-height: 20px;
    }

    .chart-box {
      border: 1px solid var(--ring);
      border-radius: 8px;
      padding: 14px;
      background: #fafafa;
    }

    .chart-title {
      margin: 0 0 8px;
      font-size: 13px;
      font-weight: 700;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    #scatterChart {
      position: relative;
    }

    #scatterChart svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .scatter-tooltip {
      position: absolute;
      z-index: 2;
      max-width: 320px;
      padding: 6px 8px;
      border-radius: 6px;
      background: rgba(31, 35, 40, 0.92);
      color: #f9fafb;
      font-size: 12px;
      line-height: 1.3;
      pointer-events: none;
      opacity: 0;
      transform: translate(-50%, -110%);
      transition: opacity 0.12s ease;
      white-space: nowrap;
    }

    .scatter-tooltip.show {
      opacity: 1;
    }

    .fade-in {
      animation: fadeUp 0.6s ease both;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <header class="fade-in">
    <h1>Scatter Plot</h1>
    <div class="subtitle">2列データをコピペして、散布図を描写!</div>
  </header>

  <main>
    <section class="panel fade-in">
      <div class="grid">
        <div>
          <label for="dataInput">データ（タブ/カンマ/空白区切り）</label>
          <textarea id="dataInput" placeholder="x	y&#10;22	14&#10;30	16&#10;28	23"></textarea>
          <div class="muted" style="margin-top: 6px;" id="delimiterNote"></div>
          <div class="muted" style="margin-top: 6px;" id="skipNotice"></div>
          <div class="error" id="mainDataError"></div>
          <div style="margin-top: 14px;">
            <label for="extraInput">追加データ（任意）</label>
            <textarea id="extraInput" placeholder="label	a	b&#10;foo	12	3&#10;bar	8	5"></textarea>
            <div class="error" id="extraError"></div>
          </div>
        </div>
        <div>
          <div class="muted" style="margin-bottom: 8px;">データ概要</div>
          <table class="stats-table">
            <thead>
              <tr><th>指標</th><th>値</th></tr>
            </thead>
            <tbody>
              <tr><td>行数</td><td id="parsedRows">-</td></tr>
              <tr><td>filtered</td><td id="filteredRows">-</td></tr>
              <tr><td>plotted</td><td id="plottedRows">-</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="panel fade-in">
      <div class="chart-box">
        <div class="chart-title">Scatter</div>
        <div id="scatterChart"></div>
      </div>
    </section>

    <section class="panel fade-in">
      <div class="grid">
        <div>
          <label class="toggle">
            <input type="checkbox" id="hasHeader" checked />
            1行目をheaderとして扱う
          </label>
          <label class="toggle">
            <input type="checkbox" id="swapAxes" />
            x軸 / y軸を入れ替える
          </label>
          <label class="toggle">
            <input type="checkbox" id="jitter" />
            ジッターを有効化
          </label>
          <label class="toggle">
            <input type="checkbox" id="showTrendline" />
            トレンドラインを表示
          </label>
          <div style="margin-top: 10px;">
            <label for="labelColumn">label列</label>
            <select id="labelColumn">
              <option value="">なし</option>
            </select>
          </div>
          <div style="margin-top: 10px;">
            <label for="filterExpr">filter条件</label>
            <input type="text" id="filterExpr" placeholder="例: a > 0 & b <= 100" />
            <div class="muted" style="margin-top: 6px;" id="detectedColumns"></div>
          </div>
        </div>
        <div>
          <div style="margin-bottom: 12px;">
            <label for="lineFormula">参照線</label>
            <input type="text" id="lineFormula" placeholder="例: y=x/2+5" />
          </div>
          <div style="margin-bottom: 12px;">
            <label for="xUpper">x upper</label>
            <input type="number" id="xUpper" step="any" placeholder="例: 30" />
          </div>
          <div>
            <label for="yUpper">y upper</label>
            <input type="number" id="yUpper" step="any" placeholder="例: 20" />
          </div>
        </div>
      </div>
      <div class="error" id="error"></div>
    </section>
  </main>

  <script>
    const MAX_COLUMNS = 10;

    const formatNum = (v) => {
      if (!Number.isFinite(v)) return "-";
      return Number.isInteger(v) ? v.toFixed(0) : v.toFixed(2);
    };

    const escapeXml = (raw) => String(raw)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");

    const parseCellNumber = (raw, removeComma) => {
      const hasPercent = raw.includes("%");
      let cleaned = raw.trim();
      if (removeComma) cleaned = cleaned.replace(/,/g, "");
      if (hasPercent) cleaned = cleaned.replace(/%/g, "");
      const num = Number(cleaned);
      if (!Number.isFinite(num)) return NaN;
      return hasPercent ? num / 100 : num;
    };

    const parseFilterValue = (raw, removeComma) => {
      const maybeNum = parseCellNumber(raw, removeComma);
      if (Number.isFinite(maybeNum)) return maybeNum;
      return raw.trim();
    };

    const splitRow = (line) => {
      if (line.includes("\t")) return line.split("\t");
      if (line.includes(",")) return line.split(",");
      return line.trim().split(/\s+/);
    };

    const parseTable = (raw, hasHeader) => {
      const hasTab = raw.includes("\t");
      const hasNewline = raw.includes("\n");
      const removeComma = hasTab || hasNewline;
      const lines = raw
        .replace(/\r\n?/g, "\n")
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l.length > 0);

      let header = ["x", "y"];
      const rows = [];
      let skipped = 0;
      let maxCols = 2;
      if (lines.length === 0) return { header, rows, skipped, maxCols, removeComma };

      let startIndex = 0;
      if (hasHeader) {
        const headCells = splitRow(lines[0]).map((c) => c.trim()).slice(0, MAX_COLUMNS);
        maxCols = Math.max(maxCols, headCells.length);
        header = Array.from({ length: maxCols }, (_, i) => {
          const v = headCells[i];
          if (v && v.length > 0) return v;
          if (i === 0) return "x";
          if (i === 1) return "y";
          return `col${i + 1}`;
        });
        startIndex = 1;
      }

      for (let i = startIndex; i < lines.length; i += 1) {
        const cells = splitRow(lines[i]).map((c) => c.trim()).slice(0, MAX_COLUMNS);
        maxCols = Math.max(maxCols, cells.length);
        if (cells.length < 2) {
          skipped += 1;
          continue;
        }
        const a = parseCellNumber(cells[0], removeComma);
        const b = parseCellNumber(cells[1], removeComma);
        if (!Number.isFinite(a) || !Number.isFinite(b)) {
          skipped += 1;
          continue;
        }
        rows.push({ x: a, y: b, cells });
      }

      if (!hasHeader) {
        header = Array.from({ length: maxCols }, (_, i) => {
          if (i === 0) return "x";
          if (i === 1) return "y";
          return `col${i + 1}`;
        });
      } else if (header.length < maxCols) {
        for (let i = header.length; i < maxCols; i += 1) {
          header.push(`col${i + 1}`);
        }
      }

      return { header, rows, skipped, maxCols, removeComma };
    };

    const parseExtraTable = (raw, hasHeader) => {
      const hasTab = raw.includes("\t");
      const hasNewline = raw.includes("\n");
      const removeComma = hasTab || hasNewline;
      const lines = raw
        .replace(/\r\n?/g, "\n")
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l.length > 0);

      let header = [];
      const rows = [];
      const maxExtraCols = Math.max(0, MAX_COLUMNS - 2);
      let maxCols = 0;
      if (lines.length === 0) return { header, rows, maxCols, removeComma };

      let startIndex = 0;
      if (hasHeader) {
        const headCells = splitRow(lines[0]).map((c) => c.trim()).slice(0, maxExtraCols);
        maxCols = Math.max(maxCols, headCells.length);
        header = Array.from({ length: maxCols }, (_, i) => {
          const v = headCells[i];
          return v && v.length > 0 ? v : `col${i + 3}`;
        });
        startIndex = 1;
      }

      for (let i = startIndex; i < lines.length; i += 1) {
        const cells = splitRow(lines[i]).map((c) => c.trim()).slice(0, maxExtraCols);
        maxCols = Math.max(maxCols, cells.length);
        rows.push(cells);
      }

      if (!hasHeader) {
        header = Array.from({ length: maxCols }, (_, i) => `col${i + 3}`);
      } else if (header.length < maxCols) {
        for (let i = header.length; i < maxCols; i += 1) {
          header.push(`col${i + 3}`);
        }
      }

      return { header, rows, maxCols, removeComma };
    };

    const normalizeFilterExpr = (rawExpr) => rawExpr
      .replace(/&&/g, "__AND__")
      .replace(/\|\|/g, "__OR__")
      .replace(/&/g, "&&")
      .replace(/\|/g, "||")
      .replace(/__AND__/g, "&&")
      .replace(/__OR__/g, "||");

    const buildFilterEvaluator = (rawExpr, headers, maxCols) => {
      if (!rawExpr || rawExpr.trim() === "") return null;
      const expr = normalizeFilterExpr(rawExpr.trim());
      const allowedChars = /^[\w\s<>=!&|().,+\-*/%"'[\]]+$/;
      if (!allowedChars.test(expr)) {
        throw new Error("filter条件に使えない文字が含まれています。");
      }
      if (/\b(this|Function|constructor|globalThis|window|document|eval)\b/.test(expr)) {
        throw new Error("filter条件に使えないキーワードが含まれています。");
      }

      const argNames = [];
      const colToArg = [];
      for (let i = 0; i < Math.min(maxCols, MAX_COLUMNS); i += 1) {
        const colArg = `col${i + 1}`;
        argNames.push(colArg);
        colToArg[i] = [colArg];
        const header = headers[i] || "";
        if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(header) && header !== colArg) {
          argNames.push(header);
          colToArg[i].push(header);
        }
      }

      const tokens = expr.match(/[A-Za-z_][A-Za-z0-9_]*/g) || [];
      const allowedNames = new Set(argNames.concat(["true", "false", "null"]));
      for (const t of tokens) {
        if (!allowedNames.has(t)) {
          throw new Error(`filter条件の列名 "${t}" を解釈できません。`);
        }
      }

      // eslint-disable-next-line no-new-func
      const fn = new Function(...argNames, `return (${expr});`);
      return (values) => {
        const valueMap = {};
        for (let i = 0; i < colToArg.length; i += 1) {
          const v = values[i];
          for (const name of colToArg[i]) {
            valueMap[name] = v;
          }
        }
        const args = argNames.map((n) => valueMap[n]);
        return Boolean(fn(...args));
      };
    };

    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = String(value);
    };

    const jitterOffset = (index, axisScale) => {
      const base = Math.sin((index + 1) * 12.9898) * 43758.5453;
      const frac = base - Math.floor(base);
      return (frac - 0.5) * axisScale;
    };

    const buildLineEvaluator = (rawFormula) => {
      if (!rawFormula || rawFormula.trim() === "") return null;
      let expr = rawFormula.trim();
      expr = expr.replace(/^y\s*=\s*/i, "");
      if (expr.length === 0) return null;

      const isSafe = /^[0-9xX+\-*/().,\s^a-zA-Z_]*$/.test(expr);
      if (!isSafe) throw new Error("関数は英数と + - * / () を使ってください。");

      const normalized = expr
        .replace(/\^/g, "**")
        .replace(/\b([a-zA-Z_]+)\s*\(/g, (m, fn) => {
          if (fn.toLowerCase() === "math") return m;
          return `Math.${fn}(`;
        })
        .replace(/\bx\b/gi, "x");

      // eslint-disable-next-line no-new-func
      const fn = new Function("x", `return (${normalized});`);
      return (x) => {
        const y = fn(x);
        return Number.isFinite(y) ? y : NaN;
      };
    };

    const niceStep = (maxValue, targetTicks = 6) => {
      if (!Number.isFinite(maxValue) || maxValue <= 0) return 1;
      const raw = maxValue / Math.max(targetTicks, 2);
      const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
      const frac = raw / pow10;
      let niceFrac = 10;
      if (frac <= 1) niceFrac = 1;
      else if (frac <= 2) niceFrac = 2;
      else if (frac <= 5) niceFrac = 5;
      else niceFrac = 10;
      return niceFrac * pow10;
    };

    const buildTrendlineEvaluator = (points) => {
      if (!points || points.length < 2) return null;
      const n = points.length;
      let sumX = 0;
      let sumY = 0;
      let sumXX = 0;
      let sumXY = 0;
      for (const p of points) {
        sumX += p.x;
        sumY += p.y;
        sumXX += p.x * p.x;
        sumXY += p.x * p.y;
      }
      const denom = n * sumXX - sumX * sumX;
      if (!Number.isFinite(denom) || Math.abs(denom) < 1e-12) return null;
      const slope = (n * sumXY - sumX * sumY) / denom;
      const intercept = (sumY - slope * sumX) / n;
      if (!Number.isFinite(slope) || !Number.isFinite(intercept)) return null;
      return (x) => slope * x + intercept;
    };

    const updateLabelColumnOptions = (headers, maxCols) => {
      const selectEl = document.getElementById("labelColumn");
      if (!selectEl) return "";
      const prev = selectEl.value;
      const options = ['<option value="">なし</option>'];
      for (let i = 2; i < Math.min(maxCols, MAX_COLUMNS); i += 1) {
        const colName = headers[i] && headers[i].trim() !== "" ? headers[i] : `col${i + 1}`;
        options.push(`<option value="${i}">${colName}</option>`);
      }
      selectEl.innerHTML = options.join("");
      if (prev !== "" && Number.isInteger(Number(prev)) && Number(prev) < maxCols) {
        selectEl.value = prev;
      }
      return selectEl.value;
    };

    const renderScatter = (points, xLabel, yLabel, jitterOn, lineEval, labelHeader, showTrendline) => {
      const container = document.getElementById("scatterChart");
      if (points.length === 0) {
        container.innerHTML = '<div class="muted">描写できる点がありません。</div>';
        return;
      }

      const width = 760;
      const height = 420;
      const pad = { top: 24, right: 24, bottom: 56, left: 60 };
      const innerW = width - pad.left - pad.right;
      const innerH = height - pad.top - pad.bottom;

      const minX = 0;
      const minY = 0;
      const maxXData = Math.max(...points.map((p) => p.x));
      const maxYData = Math.max(...points.map((p) => p.y));
      const xStep = niceStep(maxXData);
      const yStep = niceStep(maxYData);
      const maxX = Math.max(xStep, Math.ceil(Math.max(maxXData, 0) / xStep) * xStep);
      const maxY = Math.max(yStep, Math.ceil(Math.max(maxYData, 0) / yStep) * yStep);

      const spanX = maxX - minX;
      const spanY = maxY - minY;
      const xFor = (x) => pad.left + ((x - minX) / spanX) * innerW;
      const yFor = (y) => pad.top + innerH - ((y - minY) / spanY) * innerH;
      const jitterX = jitterOn ? Math.max(spanX * 0.01, 0.005) : 0;
      const jitterY = jitterOn ? Math.max(spanY * 0.01, 0.005) : 0;

      const gridLines = [];
      for (let xTick = 0; xTick <= maxX + xStep / 2; xTick += xStep) {
        const px = xFor(xTick);
        gridLines.push(
          `<line x1="${px}" y1="${pad.top}" x2="${px}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.08)" />`,
          `<text x="${px}" y="${pad.top + innerH + 18}" text-anchor="middle" font-size="11" fill="#6b7280">${formatNum(xTick)}</text>`
        );
      }
      for (let yTick = 0; yTick <= maxY + yStep / 2; yTick += yStep) {
        const py = yFor(yTick);
        gridLines.push(
          `<line x1="${pad.left}" y1="${py}" x2="${pad.left + innerW}" y2="${py}" stroke="rgba(31,35,40,0.08)" />`,
          `<text x="${pad.left - 8}" y="${py + 4}" text-anchor="end" font-size="11" fill="#6b7280">${formatNum(yTick)}</text>`
        );
      }

      const dots = points
        .map((p, idx) => {
          const jx = jitterOffset(idx, jitterX);
          const jy = jitterOffset(idx + 999, jitterY);
          const cx = xFor(p.x + jx);
          const cy = yFor(p.y + jy);
          const labelText = labelHeader && p.label ? `${p.label} ` : "";
          const title = `${labelText}(${formatNum(p.x)}, ${formatNum(p.y)})`;
          return `<circle class="scatter-point" cx="${cx}" cy="${cy}" r="4" fill="#3b3f45" opacity="0.78" data-tip="${escapeXml(title)}"><title>${escapeXml(title)}</title></circle>`;
        })
        .join("");

      const buildFunctionPath = (fn, stroke, strokeWidth, dasharray = "") => {
        if (!fn) return "";
        const segments = [];
        const steps = 180;
        let current = [];
        for (let i = 0; i <= steps; i += 1) {
          const x = (maxX * i) / steps;
          const y = fn(x);
          if (!Number.isFinite(y)) {
            if (current.length > 1) segments.push(current);
            current = [];
            continue;
          }
          const cx = xFor(x);
          const cy = yFor(y);
          if (cy < pad.top - 1 || cy > pad.top + innerH + 1) {
            if (current.length > 1) segments.push(current);
            current = [];
            continue;
          }
          current.push(`${cx},${cy}`);
        }
        if (current.length > 1) segments.push(current);
        return segments
          .map((pts) => `<polyline points="${pts.join(" ")}" fill="none" stroke="${stroke}" stroke-width="${strokeWidth}"${dasharray ? ` stroke-dasharray="${dasharray}"` : ""} />`)
          .join("");
      };

      const linePath = buildFunctionPath(lineEval, "#8f98a3", 2, "6 6");
      const trendEval = showTrendline ? buildTrendlineEvaluator(points) : null;
      const trendPath = buildFunctionPath(trendEval, "#9ca3af", 1.2);

      container.innerHTML = [
        `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Scatter plot">`,
        `<rect x="0" y="0" width="${width}" height="${height}" fill="transparent" />`,
        ...gridLines,
        `<line x1="${pad.left}" y1="${pad.top + innerH}" x2="${pad.left + innerW}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.26)" />`,
        `<line x1="${pad.left}" y1="${pad.top}" x2="${pad.left}" y2="${pad.top + innerH}" stroke="rgba(31,35,40,0.26)" />`,
        linePath,
        trendPath,
        dots,
        `<text x="${pad.left + innerW / 2}" y="${height - 12}" text-anchor="middle" font-size="12" fill="#4b5563">${xLabel}</text>`,
        `<text x="16" y="${pad.top + innerH / 2}" text-anchor="middle" font-size="12" fill="#4b5563" transform="rotate(-90 16 ${pad.top + innerH / 2})">${yLabel}</text>`,
        `</svg>`,
      ].join("");

      const tooltip = document.createElement("div");
      tooltip.className = "scatter-tooltip";
      container.appendChild(tooltip);

      const pointEls = container.querySelectorAll(".scatter-point");
      pointEls.forEach((el) => {
        el.addEventListener("mouseenter", () => {
          tooltip.textContent = el.getAttribute("data-tip") || "";
          tooltip.classList.add("show");
        });
        el.addEventListener("mouseleave", () => {
          tooltip.classList.remove("show");
        });
        el.addEventListener("mousemove", (ev) => {
          const rect = container.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          tooltip.style.left = `${x}px`;
          tooltip.style.top = `${y}px`;
        });
      });
    };

    const build = () => {
      const raw = document.getElementById("dataInput").value;
      const extraRaw = document.getElementById("extraInput").value;
      const hasHeader = document.getElementById("hasHeader").checked;
      const swapAxes = document.getElementById("swapAxes").checked;
      const jitterOn = document.getElementById("jitter").checked;
      const showTrendline = document.getElementById("showTrendline").checked;
      const filterExpr = document.getElementById("filterExpr").value;
      const lineFormula = document.getElementById("lineFormula").value;
      const xUpperRaw = document.getElementById("xUpper").value.trim();
      const yUpperRaw = document.getElementById("yUpper").value.trim();
      const errorEl = document.getElementById("error");
      const mainDataErrorEl = document.getElementById("mainDataError");
      const extraErrorEl = document.getElementById("extraError");
      const detectedColumnsEl = document.getElementById("detectedColumns");
      const noteEl = document.getElementById("delimiterNote");

      errorEl.textContent = "";
      if (mainDataErrorEl) mainDataErrorEl.textContent = "";
      if (extraErrorEl) extraErrorEl.textContent = "";
      const hasTab = raw.includes("\t");
      const hasComma = raw.includes(",");
      const hasPercent = /(^|[\s,\t])[-+]?\d[\d,]*(\.\d+)?\s*%/.test(raw);
      const notes = [];
      notes.push(
        hasTab
          ? "タブ区切りとして検出しています。"
          : hasComma
            ? "カンマ区切りとして検出しています。"
            : "空白区切りとして検出しています。"
      );
      if (hasPercent) notes.push("百分率に直して扱います。");
      if (hasComma && (hasTab || raw.includes("\n"))) {
        notes.push("カンマは除去して扱います。");
      }
      noteEl.textContent = notes.join(" ");

      const xUpper = xUpperRaw === "" ? NaN : Number(xUpperRaw);
      const yUpper = yUpperRaw === "" ? NaN : Number(yUpperRaw);
      if ((xUpperRaw !== "" && !Number.isFinite(xUpper)) || (yUpperRaw !== "" && !Number.isFinite(yUpper))) {
        errorEl.textContent = "x upper / y upper には数値を入力してください。";
        return;
      }
      let lineEval = null;
      try {
        lineEval = buildLineEvaluator(lineFormula);
      } catch (e) {
        errorEl.textContent = e instanceof Error ? e.message : "関数の解釈に失敗しました。";
        return;
      }

      const parsed = parseTable(raw, hasHeader);
      if (parsed.maxCols > 2) {
        if (mainDataErrorEl) mainDataErrorEl.textContent = "メインデータは2列にしてください!";
        document.getElementById("scatterChart").innerHTML = "";
        return;
      }
      const extraParsed = parseExtraTable(extraRaw, hasHeader);
      const hasExtra = extraRaw.trim().length > 0;
      if (hasExtra && parsed.rows.length !== extraParsed.rows.length) {
        if (extraErrorEl) extraErrorEl.textContent = "行数が異なります!";
        document.getElementById("scatterChart").innerHTML = "";
        return;
      }

      const mergedHeaders = [
        parsed.header[0] || "x",
        parsed.header[1] || "y",
        ...extraParsed.header,
      ].slice(0, MAX_COLUMNS);
      if (detectedColumnsEl) {
        const hasAnyInput = raw.trim().length > 0 || extraRaw.trim().length > 0;
        detectedColumnsEl.textContent = hasAnyInput
          ? `検出カラム: ${mergedHeaders.join(", ")}`
          : "";
      }
      let rows = parsed.rows.map((r, idx) => {
        const extraCells = hasExtra ? (extraParsed.rows[idx] || []) : [];
        const cells = [r.cells[0] ?? "", r.cells[1] ?? "", ...extraCells].slice(0, MAX_COLUMNS);
        const filterValues = [
          parseFilterValue(cells[0] ?? "", parsed.removeComma),
          parseFilterValue(cells[1] ?? "", parsed.removeComma),
          ...extraCells.map((c) => parseFilterValue(c, extraParsed.removeComma)),
        ].slice(0, MAX_COLUMNS);
        return { x: r.x, y: r.y, cells, filterValues };
      });
      const mergedMaxCols = Math.min(MAX_COLUMNS, Math.max(2, mergedHeaders.length));

      let filterEval = null;
      try {
        filterEval = buildFilterEvaluator(filterExpr, mergedHeaders, mergedMaxCols);
      } catch (e) {
        errorEl.textContent = e instanceof Error ? e.message : "filter条件の解釈に失敗しました。";
        return;
      }
      const skipNoticeEl = document.getElementById("skipNotice");
      const selectedLabelColRaw = updateLabelColumnOptions(mergedHeaders, mergedMaxCols);
      const selectedLabelCol = selectedLabelColRaw === "" ? -1 : Number(selectedLabelColRaw);
      const labelHeader = selectedLabelCol >= 2 ? (mergedHeaders[selectedLabelCol] || `col${selectedLabelCol + 1}`) : "";
      let xLabel = mergedHeaders[0] || "x";
      let yLabel = mergedHeaders[1] || "y";

      if (swapAxes) {
        rows = rows.map((r) => ({ x: r.y, y: r.x }));
        const tmp = xLabel;
        xLabel = yLabel;
        yLabel = tmp;
      }

      const filteredRows = filterEval
        ? rows.filter((r) => filterEval(r.filterValues))
        : rows;

      const plotted = filteredRows.filter((r) => {
        if (Number.isFinite(xUpper) && r.x > xUpper) return false;
        if (Number.isFinite(yUpper) && r.y > yUpper) return false;
        return true;
      }).map((r) => {
        if (selectedLabelCol < 2 || !Number.isInteger(selectedLabelCol)) return { ...r, label: "" };
        const rawLabel = r.cells[selectedLabelCol] ?? "";
        return { ...r, label: rawLabel };
      });

      setText("parsedRows", rows.length);
      setText("filteredRows", filteredRows.length);
      setText("plottedRows", plotted.length);
      if (skipNoticeEl) {
        skipNoticeEl.textContent = parsed.skipped > 0
          ? `数値として読めなかったデータは読み込みをスキップしました（${parsed.skipped}件）`
          : "";
      }

      renderScatter(plotted, xLabel, yLabel, jitterOn, lineEval, labelHeader, showTrendline);
    };

    const debounce = (fn, wait = 180) => {
      let t = null;
      return (...args) => {
        window.clearTimeout(t);
        t = window.setTimeout(() => fn(...args), wait);
      };
    };

    const debouncedBuild = debounce(build, 180);

    document.getElementById("dataInput").addEventListener("input", debouncedBuild);
    document.getElementById("extraInput").addEventListener("input", debouncedBuild);
    document.getElementById("hasHeader").addEventListener("change", build);
    document.getElementById("swapAxes").addEventListener("change", build);
    document.getElementById("jitter").addEventListener("change", build);
    document.getElementById("showTrendline").addEventListener("change", build);
    document.getElementById("labelColumn").addEventListener("change", build);
    document.getElementById("filterExpr").addEventListener("input", debouncedBuild);
    document.getElementById("lineFormula").addEventListener("input", debouncedBuild);
    document.getElementById("xUpper").addEventListener("input", debouncedBuild);
    document.getElementById("yUpper").addEventListener("input", debouncedBuild);

    build();
  </script>
</body>
</html>
